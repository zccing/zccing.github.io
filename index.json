[{"categories":null,"content":"待更新 ","date":"2017-08-20","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["network"],"content":"在各大云服务器厂商的现有Ubuntu系统的基础上重新安装MikroTik的CHR版本软路由系统","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"在各大云服务器厂商的现有Ubuntu系统的基础上重新安装MikroTik的CHR版本软路由系统 ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:0:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"1 前置条件 此文档使用的Ubuntu系统版本是16.04或者18.04 Ubuntu系统只挂载了一个磁盘, 磁盘20G以上空间即可，多了浪费 此文档使用的Ubuntu系统的网卡是自动获取IP地址 ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:1:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"2 下载MikroTik的CHR版本镜像 MikroTik的CHR版本下载页面：https://mikrotik.com/download # 更新存储库，并下载wget和unzip程序 apt update \u0026\u0026 apt install -y wget unzip # 下载CHR镜像 wget https://download.mikrotik.com/routeros/7.5/chr-7.5.img.zip # 解压CHR镜像 gunzip -c chr-7.5.img.zip \u003e chr.img ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:2:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"3 挂载镜像 # 安装kpartx apt-get install kpartx # 挂载镜像 kpartx -av chr.img mount -o loop /dev/mapper/loop0p1 /mnt ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:3:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"4 修改ssh端口 MikroTik系统的默认ssh端口是22，云服务器会根据安全需求，变更ssh端口的，所以我们要更改MikroTik系统镜像的ssh配置 # 检查设备上的SSH端口 ss -tnlp | grep sshd 服务器系统配置的ssh端口 # 将7272替换成实际的ssh端口 cat \u003e\u003e /mnt/rw/autorun.scr\u003c\u003c\"EOF\" /ip service set ssh port=7272 disabled=no \"EOF\" ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:4:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"5 卸载镜像 umount /mnt kpartx -dv /dev/loop0 losetup -d /dev/loop0 ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:5:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"6 查看Ubuntu系统的盘符标识 # 命令 lsblk # 命令执行后的回显，此回显中的 vda 就是盘符标识 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 252:0 0 25G 0 disk └─vda1 252:1 0 25G 0 part / 物理磁盘的盘符 ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:6:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"7 Ubuntu系统挂载为只读 echo u \u003e /proc/sysrq-trigger ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:7:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"8 替换Ubuntu系统为MikroTik系统 # 注意替换vda为实际的盘符标识 dd if=chr.img bs=1024 of=/dev/vda ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:8:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["network"],"content":"9 重启系统 echo s \u003e /proc/sysrq-trigger \u0026\u0026 sleep 5 \u0026\u0026 echo b \u003e /proc/sysrq-trigger 至此，云服务器已经是ROS系统了，重新使用admin用户名登陆设备。 ","date":"2022-08-27","objectID":"/posts/network/mikrotik-to-cloud-server/:9:0","tags":["flash"],"title":"云服务器刷MikroTik系统教程","uri":"/posts/network/mikrotik-to-cloud-server/"},{"categories":["Route Protocol"],"content":"Routing information protocol(RIP)是一种基于距离矢量（Distance-Vector，D-V）算法的协议","date":"2022-08-23","objectID":"/posts/network/01-rip/","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"Routing information protocol(RIP)是一种基于距离矢量（Distance-Vector，D-V）算法的路由协议, 配置非常简单, RIP有Version 1和Version 2两个版本，Version 1已过时，所以本篇文章只记录Version 2的设置。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:0:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"1 基本概念 RIP是一种基于距离矢量（Distance-Vector，D-V）算法的协议，它通过UDP报文进行路由信息的交换，使用的端口号为520/UDP。 RIP使用跳数（Hop Count）来衡量到达目的地址的距离，称为度量值（Routing Cost）。 在 RIP 中，路由器到与它直接相连网络的跳数为 0，通过一个路由器可达的网络的跳数为 1，其余依此类推。 为限制收敛时间，RIP 规定度量值取 0～15 之 间的整数，大于或等于 16的跳数被定义为无穷大，即目的网络或主机不可达。 由于跳数限制，使得RIP不适合应用于大型网络。 为提高性能，防止产生路由环路，RIP支持水平分割（Split Horizon）和毒性逆转（Poison Reverse）功能功能。 RIP还可引入其它路由协议所得到的路由。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:1:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"1.1 RIP的启动和运行过程 RIP 工作过程分析 初始状态：某路由器刚启动 RIP 时，以广播、组播或单播的形式向运行 RIP 协议的相邻路由器发送请求报文，相邻路由器收到请求报文后，响应该请求，回送包含本地路由表信息的响应报文。 构建路由表：路由器收到响应报文后，更新本地路由表，同时向运行 RIP协议的相邻路由器发送触发更新报文，通告路由更新信息。相邻路由器收到触发更新报文后，又向其各自的相邻路由器发送触发更新报文。在一连串的触发更新后，各路由器都能得到并保持最新的路由信息。 维护路由表：路由器每隔30秒发送更新报文，同时接收相邻路由器发送的更新报文以维护路由表项。 老化路由表项：路由器为将自己构建的路由表项启动180秒的定时器。180秒内，如果路由器收到更新报文，则重置自己的更新定时器和老化定时器。 垃圾收集表项：如果180秒过后，路由器没有收到相应路由表项的更新，则启动时长为120秒的垃圾收集定时器，同时将该路由表项的度量置为16。 删除路由表项：如果60秒之后，路由器仍然没有收到相应路由表项的更新，则路由器将该表项删除 正常情况下，每30秒路由器就可以收到一次路由信息更新，如果经过180秒，即6个更新周期，一个路由项都没有得到更新，路由器就认为它已失效了。如果经过240秒，即8个更新周期，路由项仍没有得到更新，它就被从路由表中删除。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:1:1","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"2 拓扑图 本篇文章涉及的拓扑如下： 本文涉及的实验拓扑 R1和R2通过单播建立邻居 R1和R3使用组播建立邻居 R2和R4通过广播建立邻居 R4和R5通过不同版本建立邻居 R4和R5启用密码认证的 R4的传递的192.168.47.0/24路由Metric设置为6 R3和R4不建立邻居 R1发布默认路由，R3不能学到默认路由 当R1的lookback0中断后，不发布默认路由 R4过滤从R2学到的10.1.13.0/24的路由 R4汇总一条10.1.0.0/16的路由给R5 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:2:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"3 建立邻居（neighbors） ","date":"2022-08-23","objectID":"/posts/network/01-rip/:3:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"3.1 组播方式（Multicast） R1和R3使用组播建立邻居，组播地址: 224.0.0.9 # R1 interface GigabitEthernet2 ip address 10.1.13.1 255.255.255.0 router rip version 2 # 设置RIP版本 network 10.0.0.0 # 宣告IP地址属于此A类网络的接口参与RIP no auto-summary # 关闭自动汇总 # R3 interface GigabitEthernet2 ip address 10.1.13.3 255.255.255.0 router rip version 2 network 10.0.0.0 no auto-summary network: 是用来宣告哪个网络会参与RIP，即该网络所在的Interface要发送RIP报文，报文内包含网络信息，不支持VLSM(可变长子网掩码) version: 变更RIP版本，默认版本是1, 这里改成2 auto-summary: 关闭路由汇总，后边再介绍这个 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:3:1","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"3.2 单播方式（Unicast) R1和R2使用单播建立邻居，网络不支持组播的时候可以选择这个 # R1 interface GigabitEthernet1 ip address 10.1.12.1 255.255.255.0 router rip version 2 passive-interface GigabitEthernet1 network 10.0.0.0 neighbor 10.1.12.2 no auto-summary # R2 interface GigabitEthernet1 ip address 10.1.12.2 255.255.255.0 router rip version 2 passive-interface GigabitEthernet1 network 10.0.0.0 neighbor 10.1.12.1 no auto-summary passive-interface: 关闭Ethernet0/0口组播更新, 后边再说此命令 neighbor: 设置单播地址 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:3:2","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"3.2 广播方式（Broadcast） R2和R4使用广播创建邻居，很少用。 # R2 interface GigabitEthernet2 ip address 10.1.24.2 255.255.255.0 ip rip v2-broadcast router rip version 2 network 10.0.0.0 no auto-summary # R4 interface GigabitEthernet2 ip address 10.1.13.3 255.255.255.0 router rip version 2 network 10.0.0.0 no auto-summary ip rip v2-broadcast: 指定此接口下使用广播方式来发送RIP报文 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:3:3","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"4 RIP的路由数据库（RIP Database） # R3 R3#show ip rip database 10.0.0.0/8 auto-summary 10.1.12.0/24 [1] via 10.1.13.1, 00:00:06, GigabitEthernet2 10.1.13.0/24 directly connected, GigabitEthernet2 10.1.24.0/24 [1] via 10.1.34.4, 00:00:04, GigabitEthernet3 10.1.34.0/24 directly connected, GigabitEthernet3 192.168.45.0/24 auto-summary 192.168.45.0/24 [1] via 10.1.34.4, 00:00:04, GigabitEthernet3 每个运行 RIP的路由器管理一个路由数据库，该路由数据库包含了到所有可达目的地的路由项，这些路由项包含下列信息： 目的地址：主机或网络的 IP地址。 下一跳地址：为到达目的地，需要经过的本路由器相邻路由器的接口 IP地址。 出接口：本路由器转发报文的出接口。 度量值：本路由器到达目的地的开销。 路由时间：从路由项最后一次被更新到现在所经过的时间，路由项每次被更新时，路由时间重置为 0。 RIP第1版本不支持变长子网和非连续网络，RIP的第2版本和OSPF则支持变长子网和非连续网络。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:4:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"5 防止路由环路（Prevent Routing Loops） 距离向量（Distance-Vector，D-V）类的算法容易产生路由循环，RIP是距离向量算法（Distance-Vector，D-V）的一种，所以它也不例外。如果网络上有路由循环，信息就会循环传递，永远不能到达目的地。为了避免这个问题，RIP等距离向量算法实现了下面4个机制。 水平分割（split horizon）: 水平分割保证路由器记住每一条路由信息的来源，并且不在收到这条信息的端口上再次发送它。这是保证不产生路由循环的最基本措施。 毒性逆转（poison reverse）: RIP从某个接口学到路由后，将该路由的度量值设置为16（不可达），并从原接口发回邻居路由器。利用这种方式，可以清除对方路由表中的无用信息。 触发更新（trigger update）: 当路由表发生变化时，更新报文立即广播给相邻的所有路由器，而不是等待30秒的更新周期。同样，当一个路由器刚启动RIP时，它广播请求报文。收到此广播的相邻路由器立即应答一个更新报文，而不必等到下一个更新周期。这样，网络拓扑的变化会最快地在网络上传播开，减少了路由循环产生的可能性。 计数到无穷大（Count to Infinity）: 即便采用了上面的几种方法，路由循环的问题也不能完全解决，只是得到了最大程度的减少。一旦路由循环真的出现，路由项的度量值就会出现计数到无穷大的情况。RIP选择16作为不可达的度量值是很巧妙的，它既足够的大，保证了多数网络能够正常运行，又足够小，使得计数到无穷大所花费的时间最短。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:5:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"6 计时器（Timer） RIP 一共有4个计时器（Timer）， 分别是更新计时器（Update Timer）、失效计时器（Invalid Timer）、抑制计时器（Hold-down Timer）和刷新计时器（Flush Timer) Update Timer: 多久发送一次更新报文，预设30秒 Invalid Timer: 没有再收到某条路由的更新报文，Invalid Timer开始倒数，倒数至0后，就会把这条路由变更成失效（possibly down）状态，并将Metric设置成16， 然后将这条路有发送给其他邻居，这样做是希望其他路由器都知道这条路由出现问题，预设是180秒 Hold-down Timer: 以下三种情况会将路由设置成Hold-down状态： Invalid timer 倒数到0 收到其他邻居告知这条路由的Metric是16（无法到达） 这条路由的度量值（Metric）变大了 进入Hold-down状态的路由不会再接受任何更新，增加稳定性，预设是180秒 Flush Timer: 当没有再收到某条路由的更新报文，刷新计时器开始倒数，倒数至0后，这条路由就会被删除，刷新计时器预设是240秒，注意Invalid Timer和Flush Timer是同时开始倒数的，Invalid Timer超时后再等60秒才删除路由 5.1 修改计时器 不建议修改，如果真的要改，请确保每一台路由器的timer都相同，否则会造成不稳定的问题。可以用 timers basic \u003cupdate\u003e \u003cinvalid\u003e \u003chold-down\u003e \u003cflush\u003e命令修改RIP的计时器, 要按照1:6:6:8的比例来设置计时器时间 conf t router rip timers basic 10 60 60 80 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:6:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"7 设置Metric RIP的Metric用跳数（Hop Count）计算的，经过N台路由器，Metric就是N 由于RIP的Metric并非有Bandwidth计算出来的，因此不能通过更改Bandwidth来改变metric。可以使用offset来进行手动修改metric。 示例： 修改R4传递的的路由条目192.168.45.0/24的Metric值为6 # R4 conf t access-list 1 permit 192.168.45.0 0.0.0.255 router rip offset-list 1 out 5 # 宣告路由时把Metric增加5 # R5 # 检查路由表中192.168.45.0/24的路由Metric变成6了 R5#show ip route rip 10.0.0.0/8 is variably subnetted, 6 subnets, 2 masks R 10.1.13.0/24 [120/1] via 10.1.12.1, 00:00:01, GigabitEthernet1 R 10.1.34.0/24 [120/1] via 10.1.24.4, 00:00:10, GigabitEthernet2 R 192.168.45.0/24 [120/6] via 10.1.24.4, 00:00:10, GigabitEthernet2 Hop Count: 经过几台路由器到达目的地，最大为15，16或以上会被认为无法到达（Unreachable）， offset-list: 增加宣告出去的路由条目的Metric值；RIP的Metric如果是16或以上会被视为Unreachable，所以只要将Metric设置为16，也可以做到路由过滤的效果 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:7:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"8 路由汇总 随着网络规模不断增大，路由条目亦会不断增加，路由汇总可以把路由组合，以减少路由条目，从而减低路由器的CPU、内存和带宽的消耗。在网络设置实施过程中切忌不能随意应用路由汇总，路由汇总只有再有合理设计及规划的基础上进行应用 路由表中没有属于汇总路由的子网路由条目，那么这个汇总路由就不会传递给邻居，这样保证了网络翻滚，优化性能。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:8:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"7.1 自动汇总（Auto Summary） RIP默认开启自动汇总的 自动汇总（Auto Summary）会使用预设的Subnet Mask, Class A IP就用/8，Class B IP就用/16， Class C IP就用/24来进行路由汇总，自动汇总会路由中网路地址变大。 自动汇总是当发送的时候满足汇总条件，才进行自动汇总，所以自动汇总的路由条目不会回传。 由于自动汇总不仅汇总本地的路由，还会汇总邻居传递过来的路由，容易产生路由黑洞，所以不建议使用自动汇总，可以采用手工汇总的方式 关闭自动汇总的命令 conf t router rip no auto-summary ","date":"2022-08-23","objectID":"/posts/network/01-rip/:8:1","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"7.2 手工汇总（Summarization） 自动汇总路由比手工汇总路由的优先级高，所以在进行手动汇总路由的时候，需要先关闭自动汇总 手工汇总2的N次方条路由为一条汇总路由条目 手工汇总路由的跳数（Metric）使用汇总前路由的最小跳数（Metric） 手工汇总路由的方法： R4汇总R1、R2和R3的传过来的路由条目，然后传递给R5；RIP的手动汇总路由的命令是再接口下的 # R4 interface GigabitEthernet1 ip address 192.168.45.4 255.255.255.0 # 手工汇总路由 ip summary-address rip 10.1.0.0 255.255.0.0 router rip version 2 network 192.168.45.0 # 宣告属于此C类网络的接口参与RIP no auto-summary # 关闭自动汇总 # R5 # 直接受到了汇总路由 R5#show ip route rip Gateway of last resort is not set 10.0.0.0/16 is subnetted, 1 subnets R 10.1.0.0 [120/1] via 192.168.45.4, 00:00:25, GigabitEthernet1 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:8:2","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"9 默认路由（Default Route） 可以使用RIP发布默认路由，假如R1发布默认路由给其他路由器，配置如下： # R1 conf t router rip default-information originate # R5 R5#show ip route rip R* 0.0.0.0/0 [120/3] via 192.168.45.4, 00:00:05, GigabitEthernet1 10.0.0.0/24 is subnetted, 4 subnets R 10.1.12.0 [120/2] via 192.168.45.4, 00:00:05, GigabitEthernet1 R 10.1.13.0 [120/3] via 192.168.45.4, 00:00:05, GigabitEthernet1 R 10.1.24.0 [120/1] via 192.168.45.4, 00:00:05, GigabitEthernet1 R 10.1.34.0 [120/1] via 192.168.45.4, 00:00:05, GigabitEthernet1 只在R1的Gi1口发布默认路由，Gi2口不下发默认路由，R3不会学习到默认路由 # R1 conf t route-map TO_R2 permit 10 set interface GigabitEthernet1 router rip default-information originate route-map TO_R2 # R3 # 默认路由没有了 R3#show ip route rip 10.0.0.0/8 is variably subnetted, 6 subnets, 2 masks R 10.1.12.0/24 [120/1] via 10.1.13.1, 00:00:14, GigabitEthernet2 R 10.1.24.0/24 [120/2] via 10.1.13.1, 00:00:14, GigabitEthernet2 R 192.168.45.0/24 [120/8] via 10.1.13.1, 00:00:14, GigabitEthernet2 当R1的Loopback0中断，R1就停止发布默认路由 # R1 conf t interface Loopback1 ip address 1.1.1.1 255.255.255.255 ip prefix-list CHECKING seq 5 permit 1.1.1.1/32 route-map TO_R2 permit 10 match ip address prefix-list CHECKING set interface GigabitEthernet1 router rip default-information originate route-map TO_R2 # 关闭R1的Loopback1接口 conf t interface Loopback1 shutdown # R2 # 默认路由立即消失了，应该是R1发布了一条毒化路由 R2#show ip route rip 10.0.0.0/8 is variably subnetted, 6 subnets, 2 masks R 10.1.13.0/24 [120/1] via 10.1.12.1, 00:00:12, GigabitEthernet1 R 10.1.34.0/24 [120/1] via 10.1.24.4, 00:00:17, GigabitEthernet2 R 192.168.45.0/24 [120/6] via 10.1.24.4, 00:00:17, GigabitEthernet2 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:9:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"10 被动接口（Passive Interface） 使用network方式建立邻居连接的时候，会通过所有匹配的接口发送路由更新组播报文，包括loopback口 可以将一个接口设置成被动接口，让它不发送路由更新组播报文 被动接口还是可以收到广播、组播和单播的路由更新报文 被动接口的网络也会添加到路由更新报文中，发送给RIP邻居 被动接口最好再两端都做，由于被动接口只接收不发送路由更新报文，会导致业务数据包来回路径不一致 配置示例，R3和R4不建立邻居，R3无法通过R4学到路由 # R3 router rip passive-interface default # 设置所有接口为被动接口 no passive-interface GigabitEthernet2 # 排除Gi2口 # R4 router rip passive-interface GigabitEthernet3 # 设置Gi3口为被动接口 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:10:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"11 路由过滤（Route Filtering） 限制RIP Route只发布某些路由，也可以控制接收方选择接收哪些路由，设定方式主要有Distribute-list、Distance和Offset-list三种， 使用者三种方式设置R4过滤从R2学到的10.1.13.0/24的路由的设置如下 Distribute-list: # R2 conf t # 这里使用扩展列表，其实使用标准列表或者prefix-list更简单 ip access-list extended 100 deny ip host 0.0.0.0 10.1.13.0 0.0.0.255 # 由于是再R2的OUT方向做的ACL，所以源地址是0.0.0.0 permit ip any any router rip distribute-list 100 out GigabitEthernet2 # R4 # 10.1.13.0/24的路由条目等待240秒后消失了 R4#show ip route rip R* 0.0.0.0/0 [120/2] via 10.1.24.2, 00:00:14, GigabitEthernet2 10.0.0.0/8 is variably subnetted, 5 subnets, 2 masks R 10.1.12.0/24 [120/1] via 10.1.24.2, 00:00:14, GigabitEthernet2 Distance: 路由不会将AD为255的路由加入路由表，所以可以通过更改学到的路由AD来达到过滤的效果，不推荐 # R4 conf t ip access-list standard AD_255 permit 10.1.13.0 0.0.0.255 router rip distance 250 10.1.24.2 0.0.0.0 AD_255 # 我这里修改AD为250，方便看到修改后的变化，如果要过滤，修改成255就好了 # R4的路由表 R4#show ip route rip R* 0.0.0.0/0 [120/2] via 10.1.24.2, 00:00:13, GigabitEthernet2 10.0.0.0/8 is variably subnetted, 6 subnets, 2 masks R 10.1.12.0/24 [120/1] via 10.1.24.2, 00:00:13, GigabitEthernet2 R 10.1.13.0/24 [250/2] via 10.1.24.2, 00:00:13, GigabitEthernet2 Offset-list: 在设置Metric的时候已经介绍过了，只需要将Metric修改为16或以上就被视为无效，这样可以做到过滤的效果，推荐用于限制传播距离的时候使用。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:11:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"12 密码认证（Authentication） RIP支持路由更新中包含密码，两端的密码都一样才可以进行路由交换,设置密码认证需要两个步骤，如下，这里设置的是R4和R5需要密码认证 设定钥匙串(Key Chain) # R4 key chain CCIE # 定义一个钥匙串 key 1 # 钥匙的ID key-string CCIE # 要是的密码 interface GigabitEthernet1 ip rip authentication mode md5 # 密码的加密方式，只能MD5加密 ip rip authentication key-chain CCIE # 配置这个接口需要密码认证，并调用这个钥匙串 # R5 key chain CCIE key 1 key-string CCIE interface GigabitEthernet1 ip rip authentication mode md5 ip rip authentication key-chain CCIE 在Interface调用钥匙串，并设置加密方法 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:12:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"13 兼容性（compatible） 当两台设备中，有一台不支持RIP V2，他们俩启用RIP协议的话，需要考虑兼容性问题，可以在高版本的路由器上，配置接口能同时收发RIP V1和V2的报文，来解决兼容性问题，这里将以R4是V2,R5是V1来做演示 # R4 配置接口可以同时收发V1和V2版本的路由更新 conf t interface GigabitEthernet1 ip rip send version 1 2 ip rip receive version 1 2 # R5 # 可以看到前边在接口下做的汇总路由失效了，是因为V1版本不支持手动汇总（VLSM的原因） R5#show ip route rip R* 0.0.0.0/0 [120/3] via 192.168.45.4, 00:00:19, GigabitEthernet1 10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks R 10.0.0.0/8 [120/1] via 192.168.45.4, 00:00:19, GigabitEthernet1 R 10.1.0.0/16 is possibly down, routing via 192.168.45.4, Gigab ","date":"2022-08-23","objectID":"/posts/network/01-rip/:13:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"14 RIP与BFD联动 双向转发检测BFD（Bidirectional Forwarding Detection）是一种用于检测邻居路由器之间链路故障的检测机制，它通常与路由协议联动，通过快速感知链路故障并通告使得路由协议能够快速地重新收敛，从而减少由于拓扑变化导致的流量丢失。在RIP与BFD联动中，BFD可以快速检测到链路故障并通知RIP协议，从而加快RIP协议对于网络拓扑变化的响应。 配置实例，R1和R2配置RIP与BFD联动 # R1 conf t interface GigabitEthernet1 ip address 10.1.12.1 255.255.255.0 bfd interval 50 min_rx 50 multiplier 5 # 配置BFD router rip version 2 passive-interface GigabitEthernet1 network 10.0.0.0 neighbor 10.1.12.2 bfd # 配置RIP和BFD联动 no auto-summary # R2 conf t interface GigabitEthernet1 ip address 10.1.12.2 255.255.255.0 bfd interval 50 min_rx 50 multiplier 5 router rip version 2 passive-interface GigabitEthernet1 network 10.0.0.0 neighbor 10.1.12.1 bfd no auto-summary # 检查 R2#show ip rip neighbors BFD Sessions created for RIP neighbors Neighbor Interface SessionHandle 10.1.12.1 GigabitEthernet1 1 R2#show bfd neighbors IPv4 Sessions NeighAddr LD/RD RH/RS State Int 10.1.12.1 4097/4097 Up Up Gi1 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:14:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"15 路由重发布（Redistribute） 可以将其他动态路由协议、静态路由或者直连重发布到RIP中，实现多种路由协议之间协同工作 配置实例：将R1的loopback0重发布到RIP中 interface Loopback1 ip address 1.1.1.1 255.255.255.255 router rip redistribute connected # 重发布静态，也可以重分布OSPF、EIGRP等其他路由协议的路由 # 此命令后边可以调用route-map，对重分布的路由条目进行过滤 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:15:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"16 故障处理（Troubleshooting） 检查接口是否在RIP中使能：使用show ip rip database 可以查看运行rip的接口； 检查对方发送版本号和本地接口接收的版本号是否匹配：缺省情况下，接口只发送RIPv1报文，但可以接收RIPv1和RIPv2报文。当入接口与收到的RIP报文使用不同的版本号时，有可能造成RIP路由不能被正确的接收； 检查在RIP中是否配置了策略，过滤掉收到的RIP路由：如果被路由策略过滤掉，则需修改路由策略； RIP使用的端口520/UDP是否被禁用； 检查接口是否配置了undo rip input/output或者rip metricin设置度量值过大； 检查接口是否配置了抑制接口； 检查路由度量值是否大于16； 检查链路两端是否配置了认证，认证的配置是否正确。 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:16:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["Route Protocol"],"content":"17 参考连接 H3C RIP技术介绍 曹世宏博客 RIP基础知识 Jan Ho的网络世界 ","date":"2022-08-23","objectID":"/posts/network/01-rip/:17:0","tags":["rip"],"title":"Routing information protocol(RIP)路由信息协议","uri":"/posts/network/01-rip/"},{"categories":["linux software"],"content":"配置PostgreSQL13主从复制(异步流复制模式), 此文章的前提是已经安装好了两台postgresql数据库服务器 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:0:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"1 环境介绍 我的环境中有两台数据库服务器；主数据库服务器IP:169.3.250.215，备数据库服务器IP:169.3.254.215 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:1:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"2 创建同步账号 只需要在主数据库节点创建，从节点不需要，等会要从主节点同步所有信息的 psql -U postgres -h localhost # 同步账号 create user repl REPLICATION LOGIN ENCRYPTED PASSWORD 'XXXXXX'; # 心跳账号，只要能登录就好 create role nobody login encrypted password 'xxxxxxx'; # 创建一个业务账号和业务数据库 create role zabbix login encrypted password 'xxxxxxx'; create database zabbix owner zabbix; # 为业务数据库加载timescale扩展, 可选,前提是安装了这个扩展 CREATE EXTENSION timescaledb; ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:2:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"3 策略放行 我这里放行了所有，只要是来自169.3.248.0/21网段的主机，都可以进行账号密码认证 # 放行所有 cat \u003e\u003e /etc/postgresql/13/main/pg_hba.conf\u003c\u003cEOF host replication all 169.3.248.0/21 md5 EOF ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:3:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"4 配置修改 这里主要修改用户主从同步的参数，主从服务器都要设置, 万一那天从服务器提升为主了呢, vim /etc/postgresql/13/main/postgresql.conf # 新增或修改下列属性设置（使用命令“/”来查找） archive_mode = off # （修改）关闭归档, 归档是定时恢复用的，流复制不是必须的 wal_level = replica # （添加） max_wal_senders = 20 # (修改) 最多有几个流复制连接 wal_sender_timeout = 60s # （修改）设置流复制主机发送数据的超时时间 max_replication_slots = 10 # (修改) 设置支持的复制槽数量 max_slot_wal_keep_size = 1G # (修改) 设置复制槽保留的wal最大大小,默认单位是M hot_standby = on # (修改) 说明这台机器不仅仅是用于数据归档，也用于数据查询 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:4:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"5 从节点同步主节点的数据库 # 同步数据 pg_basebackup -h 169.3.250.215 -U repl -p 5432 -F p -X stream -v -P -R -D /data/pgsql -C -S slave01 -l slave01 chown -R postgres:postgres -R /data/pgsql # 在从节点检查状态，查询结果为\"f\"表示主库, 't'表示从库 psql -U postgres -h localhost -c \"select pg_is_in_recovery();\" # 在主节点检查同步状态 psql -U postgres -h localhost -c \"select * from pg_stat_replication;\" -d postgres ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:5:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"pg_basebackup参数解析 pg_basebackup 在运行的PostgreSQL服务器上执行基础备份. 使用方法: pg_basebackup [选项]... 控制输出的选项: -D, --pgdata=DIRECTORY 接收基础备份到指定目录 -F, --format=p|t 输出格式 (纯文本 (缺省值), tar压缩格式) -r, --max-rate=RATE 传输数据目录的最大传输速率 (单位 kB/s, 也可以使用后缀\"k\" 或 \"M\") -R, --write-recovery-conf 为复制写配置文件 -T, --tablespace-mapping=OLDDIR=NEWDIR 将表空间由 OLDDIR 重定位到 NEWDIR --waldir=WALDIR 预写日志目录的位置 -X, --wal-method=none|fetch|stream 按指定的模式包含必需的WAL日志文件 -z, --gzip 对tar文件进行压缩输出 -Z, --compress=0-9 按给定的压缩级别对tar文件进行压缩输出 一般选项: -c, --checkpoint=fast|spread 设置检查点方式(fast或者spread) -C, --create-slot 创建复制槽 -l, --label=LABEL 设置备份标签 -n, --no-clean 出错后不清理 -N, --no-sync 不用等待变化安全的写入磁盘 -P, --progress 显示进度信息 -S, --slot=SLOTNAME 用于复制的槽名 -v, --verbose 输出详细的消息 -V, --version 输出版本信息, 然后退出 --manifest-checksums=SHA{224,256,384,512}|CRC32C|NONE use algorithm for manifest checksums --manifest-force-encode hex encode all file names in manifest --no-estimate-size do not estimate backup size in server side --no-manifest suppress generation of backup manifest --no-slot 防止创建临时复制槽 --no-verify-checksums 不验证校验和 -?, --help 显示帮助, 然后退出 联接选项: -d, --dbname=CONNSTR 连接串 -h, --host=HOSTNAME 数据库服务器主机或者是socket目录 -p, --port=PORT 数据库服务器端口号 -s, --status-interval=INTERVAL 发往服务器的状态包的时间间隔 (以秒计) -U, --username=NAME 指定连接所需的数据库用户名 -w, --no-password 禁用输入密码的提示 -W, --password 强制提示输入密码 (默认) ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:5:1","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"6 复制槽介绍 很多时候在主库产生wal日志的时候，还没有传到从库就被覆盖了，为了保证wal日志不被覆盖，postgres 就启用流复制槽，让没有传到从库的wal保存不被覆盖，新的日志继续产生。 # 创建 SELECT * FROM pg_create_physical_replication_slot('slave01'); # 查看创建的复制槽 SELECT * FROM pg_replication_slots ; # 删除复制槽, 我没有创建 SELECT * FROM pg_drop_replication_slot('slave01'); ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/:6:0","tags":["PostgreSQL"],"title":"PostgreSQL 主从复制配置","uri":"/posts/linux-software/postgresql/02-postgresql-master_slave-replication/"},{"categories":["linux software"],"content":"在debian 11系统上安装PostgreSQL13, 也可以通过本文档了解如何在其他linux发行版上安装PostgreSQL13 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:0:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"1 更新debian11的镜像源 debian11默认的镜像源是国外的，下载比较慢，替换为国内的镜像源，这里用的是阿里云镜像源 # 优化内核参数 cat \u003e /etc/sysctl.d/PostgreSQL.conf\u003c\u003cEOF vm.overcommit_memory=2 EOF sysctl -p /etc/sysctl.d/PostgreSQL.conf # 备份原来的镜像源 mv /etc/apt/sources.list /etc/apt/sources.list.bak # 更新新的阿里云镜像源 cat \u003e /etc/apt/sources.list \u003c\u003cEOF deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib EOF ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:1:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"2 添加PostgreSQL存储库 # 安装一些必要的工具 apt update \u0026\u0026 apt install -y gnupg2 wget # 创建存储库 sudo sh -c 'echo \"deb [arch=amd64] https://mirrors.aliyun.com/postgresql/repos/apt $(lsb_release -cs)-pgdg main\" \u003e /etc/apt/sources.list.d/pgdg.list' # 添加存储库的密钥 wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - # 更新存储库 apt update ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:2:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"3 下载PostgreSQL # 安装指定版本,后续的配置都是基于此版本的， 如果要安装最新版的话，命令是`apt install PostgreSQL` apt install PostgreSQL-13 -y # 将PostgreSQL添加到开机启动 systemctl enable PostgreSQL ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:3:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"4 配置数据目录 正常情况应该将数据存储到一个单独的磁盘中，和系统磁盘区分开； 我的环境中将/data目录挂载到一个单独的磁盘中，所以将数据保存到/data/pgsql目录中 创建目录，并设置权限 # 创建目录 mkdir /data/pgsql # 设置此目录的权限 chown postgres:postgres -R /data/pgsql 变更数据目录 PostgreSQL支持一台机器多实例配置（相当于一台服务器多个虚拟机），我们通过删除默认实例，重新创建一个实例并指定实例的数据目录 # 停止并删除默认安装创建的实例 pg_dropcluster --stop 13 main # 在`/data/pgsql`目录重新创建PostgreSQL实例，并初始化实例 pg_createcluster -d /data/pgsql 13 main # 启动新创建的PostgreSQL实例 pg_ctlcluster 13 main start 检查数据目录 # 切换到postgres用户，使用这个用户可以免密登录到pgsql su - postgres # 检查数据目录, 返回的结果中告诉了我们当前目录是`/data/pgsql` psql -c 'SHOW data_directory;' ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:4:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"5 修改默认PostgreSQL的密码 PostgreSQL安装成功之后，会默认创建一个名为postgres的Linux用户 初始化PostgreSQL实例后，实例数据库中会创建一名超级用户postgres和一个名为postgres的数据库 postgres的数据库中存储PostgreSQL的基础信息，例如用户信息等等，相当于MySQL中默认的名为mysql数据库 为了方便我们使用postgres账号进行管理和安全考虑，我们可以修改数据库和linux用户的账号的密码 修改linux用户postgres的密码 passwd postgres # 修改linux用户的密码，如果不明白，后边的也不要看了，看也看不懂 修改实例数据库的超级用户postgres的密码 如果linux用户的名称和超级用户的名称相同，登录数据库是不需要密码的，这个权限是在/etc/PostgreSQL/13/main/pg_hba.conf中配置，后边会讲到此文件的用法 # 切换到postgres用户，并修改数据库超级用户的密码， ‘NewPassword’替换为你的密码即可 su - postgres psql -c \"ALTER USER postgres WITH PASSWORD 'NewPassword';\" exit # 退出postgres用户，切换到root用户 psql -U postgres -h localhost # 输入刚刚更改的密码尝试连接 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:5:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"6 客户端连接认证 客户端认证是由一个/etc/PostgreSQL/13/main/pg_hba.conf配置文件控制（HBA表示基于主机的认证）；此文件在初始化数据目录时生成。 pg_hba.conf文件的每一行是一条记录，空白行和#注释字符后面的任何文本都将被忽略。记录不能跨行。一条记录由空格或table制表符分隔的域组成。在数据库、用户或地址域中 关键字all、replication等有特殊含义，并且只是匹配一个有该名字的数据库、用户或主机。官方 允许所有169.3.248.0/21网段的所有用户通过密码访问数据库 cat \u003e\u003e /etc/PostgreSQL/13/main/pg_hba.conf \u003c\u003cEOF host all all 169.3.248.0/21 md5 EOF ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:6:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"7 安装timescale扩展 PostgreSQL安装timescale扩展就可以变成一个时序数据库了,新的名字是timescaledb, 只是改变了存储和索引不影响PostgreSQL原有的主从架构和使用方式 添加存储库 # 设置timescale的存储库 apt install gnupg PostgreSQL-common apt-transport-https lsb-release wget sh -c \"echo 'deb https://packagecloud.io/timescale/timescaledb/debian/ $(lsb_release -c -s) main' \u003e /etc/apt/sources.list.d/timescaledb.list\" # 添加timescale的存储库密钥 curl -L https://packagecloud.io/timescale/timescaledb/gpgkey | sudo apt-key add - 下载并安装timescale apt install timescaledb-2-PostgreSQL-13 配置PostgreSQL支持timescale扩展 # 修改/etc/PostgreSQL/13/main/PostgreSQL.conf配置文件中的shared_preload_libraries参数，并去掉注释使其生效 vim /etc/postgresql/13/main/postgresql.conf shared_preload_libraries = 'timescaledb' # 不区分大小写 # 修改好了以后重启服务，使其加载此扩展 systemctl restart postgresql 为数据库安装timescale扩展 # 切换到postgres用户 su - postgres # 登录数据库 psql # 为所有已存在的数据库安装扩展, 由于其他数据库不支持timescaledb,所以我没用这个命令 CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE; # 创建一个测试数据库 CREATE DATABASE timeseries_test; # 查看数据库 \\l # 进入数据库 \\c timeseries_test # 为当前进入的数据安装扩展,不影响其他数据库 CREATE EXTENSION timescaledb; # 检查扩展 \\dx SELECT default_version, installed_version FROM pg_available_extensions WHERE name = 'timescaledb'; # 切换数据库 \\c PostgreSQL # 删除测试数据库 DROP DATABASE timeseries_test; ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:7:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["linux software"],"content":"8 PostgreSQL参数优化 整理了一些PostgreSQL参数的优化，仅供参考，请依照实际环境为准 # 我的PostgreSQL的实例配置文件(默认实例):/etc/PostgreSQL/13/main/PostgreSQL.conf # 新增或修改下列属性设置（使用命令“/”来查找） # （修改）监听所有IP listen_addresses = '*' # （修改）最大连接数，超过的话建议程序设置连接池减少开销 max_connections = 1000 # (修改)缓冲数据到内存中，建议设置物理内存的1/4，根据服务器负载调整设置 shared_buffers = 8GB # （修改）主要用于Postgre查询优化器,建议设置物理内存的3/4,较高的值更有可能使用索引扫描，较低的值则有可能使用顺序扫描 effective_cache_size = 24GB # （修改）用于写入临时文件之前内部排序操作和散列表使用的内存量，增加work_mem参数将使PostgreSQL可以进行更大的内存排序，和max_connections有关，连接越多占用内存越多，合理分配 # Total RAM * 0.25 / max_connections work_mem = 64M # (修改)指定维护操作使用的最大内存量，例如（Vacuum、Create Index和Alter Table Add Foreign Key），默认值是64MB。由于通常正常运行的数据库中不会有大量并发的此类操作，可以设置的较大一些，提高清理和创建索引外键的速度。 # Total RAM * 0.05 maintenance_work_mem = 2GB 推荐一个工具PostgreSQLtuner，使用此工具来优化参数 # 下载 wget https://raw.githubusercontent.com/jfcoz/PostgreSQLtuner/master/PostgreSQLtuner.pl chmod u+x PostgreSQLtuner.pl # 登录数据库，创建testdb库 psql -U postgres -h localhost -c 'CREATE DATABASE testdb;' # 运行命令 PostgreSQLtuner.pl --host=localhost --database=testdb --user=username --password=qwerty # 删除testdb库 psql -U postgres -h localhost -c 'DROP DATABASE testdb;' # 根据结果调优自己的服务器和数据库吧 ","date":"2022-03-05","objectID":"/posts/linux-software/postgresql/01-install-postgresql/:8:0","tags":["PostgreSQL"],"title":"Debian11安装PostgreSQL13","uri":"/posts/linux-software/postgresql/01-install-postgresql/"},{"categories":["code"],"content":"LoveIt主题在Hugo内置的shortcode的基础上提供多个扩展的shortcode.","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:0:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:1:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:2:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:3:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:4:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:1","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:2","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:3","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:4","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:5","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:6","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:5:7","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:6:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:7:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:8:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:8:1","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:8:2","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:8:3","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:8:4","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:9:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:10:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:10:1","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:10:2","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:10:3","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2021-12-19","objectID":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/:11:0","tags":["markdown"],"title":"LoveIt主题扩展Shortcodes","uri":"/posts/code/markdown/01-loveit%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%AE%9A%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"可以在 Hugo 的文章中使用的基本 Markdown 语法示例","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:0:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:3:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:4:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:5:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"6 强调 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:6:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:6:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:6:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:6:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:6:4","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:7:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"8 列表 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:8:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:8:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:8:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:8:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"9 代码 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:9:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:9:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:9:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:9:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:9:4","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:10:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"11 链接 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:11:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:11:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:11:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:11:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:12:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:13:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"15 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:4","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:5","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["code"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2021-12-19","objectID":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/:14:6","tags":["markdown"],"title":"Markdown语法","uri":"/posts/code/markdown/02-markdown%E8%AF%AD%E6%B3%95/"},{"categories":["linux software"],"content":"容器运行时笔记","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"1 标准 ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:1:0","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"1.1 OCI OCI（Open Container Initiative）标准是由 Docker 公司主导的一个关于容器格式和运行时的标准或规范，包含运行时标准（runtime-spec ）和容器镜像标准（image-spec） runc: OCI规范在Linux上的完整实现 ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:1:1","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"1.2 CRI k8s的容器运行时接口（CRI）。该接口是基于gRPC的，容器运行时只要实现了CRI，就能和k8s集成。 kubelet的启动参数--container-runtime和--container-runtime-endpoint使用的容器运行接口 crictl是CRI的客户端程序 ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:1:2","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"2 docker 现在安装比较新的 docker（18.09.6），会看到实际上至少会有三个组件：runC、containerd、dockerd。 dockerd 是个守护进程，直接面向用户，用户使用的命令 docker 直接调用的后端就是 dockerd；dockerd 不会直接使用 runc，而是去调用 containerd；containerd 会 fork 出一个单独子进程的 containerd-shim，使用 runc 将目标容器跑起来。 Kubelet 则是通过内置的 docker-shim 去调用 dockerd。 +--------------------+ | | | | CRI gRPC | kubelet +-----+ +---------------+ +--------------+ | | | | | | | | | | +---------------+ +--------------+ fork |container-shim +-----\u003e container | | +-------------+ | | | | +-------\u003e | | | | | | | | | | | +---------------+ +--------------+ | | A+\u003c----+ | | | | runc(OCI) | | dockershim | | dockerd | | containerd | +---------------+ +--------------+ | | +---------\u003eB +-------\u003eC | | | | | | | | | | | +-------\u003econtainer-shim +-----\u003e container | | | | | | | | | | | | +------+-------------+ +---------------+ +--------------+ +---------------+ +--------------+ | A:unix:///var/run/dockershim.sock +------\u003e ...... C:/run/containerd/containerd.sock B:/var/run/docker.sock ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:2:0","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"3 cri-containerd Containerd 也是 docker 公司实现的，后来捐献给了 CNCF。contianerd 把 dockerd 与 runc 解耦了，dockerd 不直接创建容器，而是通过 containerd 去调用 runc。从 contianerd 1.1 开始，contianerd 可以以插件的方式集成 CRI。contianerd 也可以使用除 runc 以外的容器引擎。 +--------------------+ +----------------------+ +---------------+ +--------------+ | | | | | | | | | | | | fork |container-shim +-----\u003e container | | kubelet | | containerd +----------\u003e | | | | | | | +---------------+ +--------------+ | | | | runc(OCI) | | +--------------+ | +---------------+ +--------------+ | | | | | | | | | | | | CRI-plugin | +----------\u003econtainer-shim +-----\u003e container | | | | | | | | | | | +---------\u003eA | | +---------------+ +--------------+ | | | | | | | | | +----------\u003e...... +--------------------+ +--------------+-------+ A:/run/containerd/containerd.sock ctr: containerd的客户端程序 ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:3:0","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"4 CRI-O CRI-O 是 RedHat 发布的容器运行时，旨在同时满足 CRI 标准和 OCI 标准。kubelet 通过 CRI 与 CRI-O 交互，CRI-O 通过 OCI 与 runC 交互，追求简单明了。可以看到，在这种方式下，就不需要使用 docker 了。 +----------+ +--------------+ | | | | | conmon +----------\u003e container | +-------------+ +--------------+----\u003e | | | | | | | +----------+ +--------------+ | | | | runc(OCI) | kubelet | CRI | CRI-O | +----------+ +--------------+ | +-------\u003eA | | | | | | | | +----\u003e conmon +----------\u003e container | | | | | | | | | +-------------+ +--------------+ +----------+ +--------------+ | +----\u003e...... A:/var/run/crio/crio.sock ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:4:0","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"5 总结 容器运行时是管理容器和容器镜像的程序。有两个标准，一个是 CRI-runtime，抽象了 kubelet 如何启动和管理容器，一个是 OCI-runtime，抽象了怎么调用内核 API 来管理容器。标准实际上是定义了一系列接口，让上层应用与底层实现接耦。 实现 CRI 的 runtime 有 CRI-O、CRI-containred 等，CRI 的命令行客户端是 crictl。containerd 的客户端是 ctr。dockerd 的客户端是 docker。它们通过 unix sock 与对应的 daemon 交互。 OCI 的默认实现是 runc。runc 是一个命令行工具，而不是一个 daemon。通过 runc 我们可以手动启动一个容器，也可以查看其他进程启动的容器 ","date":"2020-10-08","objectID":"/posts/linux-software/kubernetes/05-container-runtime/:5:0","tags":["kubernetes"],"title":"k8s容器运行时","uri":"/posts/linux-software/kubernetes/05-container-runtime/"},{"categories":["linux software"],"content":"通过二进制方式安装k8s高可用集群","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"1 节点信息 IP地址 主机名称 DNS记录 类型 系统 192.168.122.10 node1 node1 Worker Node/etcd centos7 192.168.122.11 node2 node2 Worker Node centos7 192.168.122.12 node3 node3 Master Node/etcd/nginx centos8 192.168.122.13 node4 node4 Master Node/etcd/nginx centos8 192.168.122.2 k8s.api vrrp 10.110.0.0/16 k8s service 10.120.0.0/16 k8s pod 电脑配置较低，这么多虚拟机跑不动，所以这一套高可用集群分两部分实施，先部署一套单Master架构（192.168.122.12），再扩容为多Master架构（上述规划），顺便熟悉下Master扩容流程 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:1:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"1.1 初始化节点 尽管主节点中包含etcd端口，但您也可以在外部或自定义端口上托管您自己的etcd集群 # 节点之间免密登录 ssh-keygen -b 2048 -t rsa ssh-copy-id root@node1 ssh-copy-id root@node2 ssh-copy-id root@node3 ssh-copy-id root@node4 scp ~/.ssh/id_rsa node1:~/.ssh/ scp ~/.ssh/id_rsa node2:~/.ssh/ scp ~/.ssh/id_rsa node3:~/.ssh/ scp ~/.ssh/id_rsa node4:~/.ssh/ # --------------以下所有节点都要设置------------------- # 关闭swap, 我没关，苦逼，内存不够 swapoff -a # 临时 sed -ri 's/.*swap.*/#\u0026/' /etc/fstab # 永久 # 根据规划设置主机名 hostnamectl set-hostname \u003chostname\u003e # 添加dns解析记录 cat \u003e\u003e /etc/hosts \u003c\u003c EOF 192.168.122.2 k8s.api 192.168.122.10 node1 192.168.122.11 node2 192.168.122.12 node3 192.168.122.13 node4 EOF # 时间同步 sed -i '3i server ntp.aliyun.com iburst' /etc/chrony.conf systemctl restart chronyd.service # 创建程序目录（所有节点） mkdir -p /opt/kubernetes/{bin,etc,ssl,logs,data} mkdir -p /opt/kubernetes/etc/conf.d # --------------以下只设置Master Node------------------- # 创建用户 sudo groupadd -r kube sudo useradd -s /sbin/nologin -M -d / -g kube -c \"Kubernetes user\" -r -K MAIL_DIR=/dev/null kube # 设置防火墙 firewall-cmd --permanent --add-port=6443/tcp # kube-api 安全端口 firewall-cmd --permanent --add-port=10250-10252/tcp firewall-cmd --reload # --------------以下只设置Wroker Node------------------- # 设置防火墙 firewall-cmd --permanent --add-port=10250/tcp firewall-cmd --permanent --add-port=30000-32767/tcp firewall-cmd --permanent --add-port=30000-32767/udp firewall-cmd --permanent --service=http firewall-cmd --permanent --service=https firewall-cmd --reload ## briger流量转到iptables模块 echo \"br_netfilter\" \u003e /etc/modules-load.d/br_netfilter.conf ## 生效 systemctl restart systemd-modules-load.service # 开启ipvs ## 安装ipset,一般默认都有 yum install ipset -y ## 为了方便查看ipvs规则我们要安装ipvsadm(可选) yum install ipvsadm -y # 将桥接的IPv4流量传递到iptables的链（所有Worker Node） cat \u003e /etc/sysctl.d/99-kubernetes-cri.conf \u003c\u003cEOF net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-ip6tables = 1 EOF sysctl --system # 生效 防火墙放行的端口介绍： 协议 方向 港口范围 目的 使用 TCP 入站 6443*，8080* Kubernetes API server 所有 TCP 入站 2379-2380 etcd server client API etcd TCP 入站 10250 Kubelet API 本机，控制平面组件 TCP 入站 10251 kube-scheduler 本机 TCP 入站 10252 kube-controller-manager 本机 TCP 入站 30000-32767 NodePort Services** 所有node节点 NodePort Services的默认端口范围。 使用 * 标记的端口号都可以自定义的，所以您需要保证所自定义的端口是开放的。 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:1:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"2 安装ETCD集群 参考 etcd安装配置 , 拷贝客户端证书到kubernetes server节点的/opt/kubernetes/ssl/目录下； 我的客户端证书：etcd-client.crt etcd-client.key etcd-ca.crt ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:2:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"3 PKI证书管理 可以参考官方文档：https://kubernetes.io/zh/docs/setup/best-practices/certificates/来生成证书 注意： 证书我是在server1（192.168.122.12）上进行生成管理的 证书的O和CN字段在RBAC授权的时候被认为是组和用户,所以请不要随意更改，不然RBAC预定义角色无法匹配，导致授权失败 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:3:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"3.1 创建CA 另外还需要获取用于服务账户管理的密钥对，也就是sa.key和sa.pub。 路径 默认 CN 描述 kube-ca.crt,key kubernetes-ca Kubernetes 通用 CA front-proxy-ca.crt,key kubernetes-front-proxy-ca 用于 [前端代理][proxy] kubernetes-ca mkdir -p ~/ca/{kube-ca,kube-proxy-ca} cd ~/ca/kube-ca openssl genrsa -out kube-ca.key 2048 openssl req -extensions v3_ca \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=kubernetes-ca/emailAddress=admin@admin.com\" \\ -new -x509 -days 14500 -sha256 \\ -key=kube-ca.key -out kube-ca.crt # 创建证书签名用的配置文件 cat \u003e kubernetes-ca.conf\u003c\u003cEOF # 用来对服务端证书签名 [ req_server ] subjectKeyIdentifier = hash basicConstraints = CA:FALSE authorityKeyIdentifier = keyid,issuer:always keyUsage = critical, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth,serverAuth subjectAltName = @alt_names # dns中kubernetes开头的是APIserver需要用到的记录 # 要包含所有master节点和负载均衡的IP地址、DNS记录 [ alt_names ] DNS.1 = kubernetes DNS.2 = kubernetes.default DNS.3 = kubernetes.default.svc DNS.4 = kubernetes.default.svc.cluster DNS.5 = kubernetes.default.svc.cluster.local DNS.6 = localhost DNS.7 = node3 DNS.8 = node4 DNS.9 = k8s.api IP.1 = 192.168.122.12 IP.2 = 192.168.122.13 IP.3 = 192.168.122.2 IP.4 = 127.0.0.1 IP.5 = 10.110.0.1 # 用来对客户端证书签名 [ req_client ] subjectKeyIdentifier = hash basicConstraints = CA:FALSE authorityKeyIdentifier = keyid,issuer:always keyUsage = critical, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth EOF # 更改权限 chmod 444 kube-ca.crt chmod 400 kube-ca.key kubernetes-front-proxy-ca cd ~/ca/kube-proxy-ca openssl genrsa -out front-proxy-ca.key 2048 openssl req -extensions v3_ca \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=kubernetes-front-proxy-ca/emailAddress=admin@admin.com\" \\ -new -x509 -days 14500 -sha256 \\ -key=front-proxy-ca.key -out front-proxy-ca.crt # 创建证书签名用的配置文件 cat \u003e front-proxy-ca.conf\u003c\u003cEOF # 用来对客户端证书签名 [ req_client ] subjectKeyIdentifier = hash basicConstraints = CA:FALSE authorityKeyIdentifier = keyid,issuer:always keyUsage = critical, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth EOF # 更改证书/密钥权限为只读 chmod 444 front-proxy-ca.crt chmod 400 front-proxy-ca.key ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:3:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"3.2 Server证书 两台api server我共用了证书，所以SAN的hostname,host_ip,advertise_ip我写了所有主机的名字; 默认 CN 父级 CA O (位于 Subject 中) 类型 主机 (SAN) kube-apiserver kubernetes-ca server [hostname], [Host_IP], [advertise_IP], 注:1 kube-apiserver-kubelet-client kubernetes-ca system:masters client front-proxy-client kubernetes-front-proxy-ca client 注1: kubeadm为负载均衡所使用的固定IP或 NS名: kubernetes、kubernetes.default、kubernetes.default.svc、 kubernetes.default.svc.cluster、kubernetes.default.svc.cluster.local apiserver证书 mkdir -p ~/ca/kube-ca/{apiserver,kubeconfig,kubelet} cd ~/ca/kube-ca/apiserver # 创建密钥 openssl genrsa -out apiserver.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=kube-apiserver/emailAddress=admin@admin.com\" \\ -key apiserver.key -out apiserver.csr # 使用kubernetes-ca进行签名获取带有SAN扩展的证书 openssl x509 -in apiserver.csr -out apiserver.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca.key -CAcreateserial \\ -req -sha256 -days 7300 \\ -extfile ../kubernetes-ca.conf -extensions req_server # 权限 rm -f apiserver.csr chmod 400 apiserver.key chmod 444 apiserver.crt apiserver-kubelet-client证书 apiserver访问kubelet的证书密钥对（RBAC会针对system:masters用户进行授权） cd ~/ca/kube-ca/apiserver # 创建密钥 openssl genrsa -out apiserver-kubelet-client.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=system:masters/emailAddress=admin@admin.com\" \\ -key apiserver-kubelet-client.key -out apiserver-kubelet-client.csr # 使用kubernetes-ca进行签名 openssl x509 -in apiserver-kubelet-client.csr -out apiserver-kubelet-client.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca.key -CAcreateserial \\ -req -sha256 -days 7300 -extfile ../kubernetes-ca.conf -extensions req_client rm -f apiserver-kubelet-client.csr chmod 400 apiserver-kubelet-client.key chmod 444 apiserver-kubelet-client.crt kubelet服务证书 kubelet也启用https了，所以要给他生成一个证书，外部访问kubelet的的程序可以根据kube-ca进行验证kubelet的服务证书，例如安装metrics-server性能指标监控程序的时候，他需要验证kubelet证书 注意：DNS和IP要写所有的安装kubelet节点的ip和主机名称 cd ~/ca/kube-ca/kubelet # 创建密钥 openssl genrsa -out kubelet.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=kube-kubelet/emailAddress=admin@admin.com\" \\ -key kubelet.key -out kubelet.csr # 创建证书签名用的配置文件 cat \u003e kubelet-cert.conf\u003c\u003cEOF # 用来对服务端证书签名 [ req_server ] subjectKeyIdentifier = hash basicConstraints = CA:FALSE authorityKeyIdentifier = keyid,issuer:always keyUsage = critical, digitalSignature, keyEncipherment extendedKeyUsage = serverAuth subjectAltName = @alt_names # 要包含所有worker节点的IP地址、DNS记录 [ alt_names ] DNS.1 = localhost DNS.2 = node1 DNS.3 = node2 IP.1 = 192.168.122.10 IP.2 = 192.168.122.11 IP.3 = 127.0.0.1 EOF # 使用kubernetes-ca进行签名获取带有SAN扩展的证书 openssl x509 -in kubelet.csr -out kubelet.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca.key -CAcreateserial \\ -req -sha256 -days 7300 \\ -extfile kubelet-cert.conf -extensions req_server # 权限 rm -f kubelet.csr chmod 400 kubelet.key chmod 444 kubelet.crt front-proxy-client证书 只有当你运行kube-proxy并要支持扩展API服务器时，才需要front-proxy证书 mkdir ~/ca/kube-proxy-ca/front-proxy-client cd ~/ca/kube-proxy-ca/front-proxy-client # 创建密钥 openssl genrsa -out front-proxy-client.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=front-proxy-client/emailAddress=admin@admin.com\" \\ -key front-proxy-client.key -out front-proxy-client.csr # 使用中间CA进行签名 openssl x509 -in front-proxy-client.csr -out front-proxy-client.crt \\ -CA ../front-proxy-ca.crt -CAkey ../front-proxy-ca.key -CAcreateserial \\ -req -sha256 -days 7300 -extfile ../front-proxy-ca.conf -extensions req_client rm -f front-proxy-client.csr chmod 400 front-proxy-client.key chmod 444 front-proxy-client.crt 服务账户管理的密钥对 cd ~/ca/kube-ca/apiserver openssl genrsa -out sa.key 2048 openssl rsa -in sa.key -pubout -out sa.pub chmod 400 sa.key chmod 444 sa.pub ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:3:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"3.3 用户证书 用户证书是kubectl、kubelet、kube-controller-manager、kube-scheduler等程序连接API server时候用到的客户端证书，可以直接写入配置文件，不需要拷贝证书/密钥到节点上， 使用kubectl创建连接apiserver的配置文件，等配置生成完后复制admin.conf到~/.kube/config, 然后删除KUBECONFIG的环境变量即可恢复kubectl对apiserver的访问 配置文件信息 文件名 命令 凭据名称 默认 CN O (位于 Subject 中) 说明 admin.conf kubectl default-admin kubernetes-admin system:masters 配置集群的管理员 kubelet.conf kubelet default-auth system:node:[nodeName] （参阅注释） system:nodes 集群中的每个节点都需要一份,配置了连接API Server等的参数 controller-manager.conf kube-controller-manager default-controller-manager system:kube-controller-manager 必需添加到 manifests/kube-controller-manager.yaml 清单中 scheduler.conf kube-scheduler default-scheduler system:kube-scheduler 必需添加到 manifests/kube-scheduler.yaml 清单中 proxy.conf kube-proxy default-proxy system:kube-proxy 集群中的每个节点都需要一份,配置了连接API Server等的参数proxy 注释：kubelet.conf中[nodeName]的值必须与kubelet向apiserver注册时提供的节点名称的值完全匹配。 有关更多详细信息，请阅读节点授权。 安装kubectl k8s集群管理工具 cd /tmp wget https://dl.k8s.io/v1.19.1/kubernetes-client-linux-amd64.tar.gz tar -zxf kubernetes-client-linux-amd64.tar.gz cp kubernetes/client/bin/kubectl /usr/bin/ rm -rf kubernetes* # kubectl命令补全 echo 'eval \"$(kubectl completion bash)\"' \u003e\u003e ~/.bashrc source ~/.bashrc admin.conf kubectl客户端连接apiserver时候使用的配置文件 kubectl客户端默认调用~/.kube/config的配置文件 可以通过KUBECONFIG变量来控制 mkdir ~/ca/kube-ca/kubeconfig cd ~/ca/kube-ca/kubeconfig # 创建密钥 openssl genrsa -out kube-admin.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=system:masters/OU=net-cc.com/CN=kubernetes-admin/emailAddress=admin@admin.com\" \\ -key kube-admin.key -out kube-admin.csr # 使用中间CA进行签名 openssl x509 -in kube-admin.csr -out kube-admin.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca.key -CAcreateserial \\ -req -sha256 -days 7300 \\ -extfile ../kubernetes-ca.conf -extensions req_client rm -f kube-admin.csr chmod 400 kube-admin.key chmod 444 kube-admin.crt # 把证书直接写道配置文件中，客户端不用保留证书了，(`--embed-certs`控制) export KUBECONFIG=admin.conf kubectl config set-cluster default-cluster --server=https://node3:6443 --certificate-authority ../kube-ca.crt --embed-certs kubectl config set-credentials default-admin --client-key kube-admin.key --client-certificate kube-admin.crt --embed-certs kubectl config set-context default-system --cluster default-cluster --user default-admin kubectl config use-context default-system kubelet.conf 两个Worker节点，node1我使用手动生成证书的方式 node2我使用自动签发证书的方式，所以这里未生成证书 cd ~/ca/kube-ca/kubeconfig export NODENAME=node1 # 创建密钥 openssl genrsa -out kube-kubelet-$NODENAME.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=system:nodes/OU=net-cc.com/CN=system:node:$NODENAME/emailAddress=admin@admin.com\" \\ -key kube-kubelet-$NODENAME.key -out kube-kubelet-$NODENAME.csr # 使用kubernetes-ca进行签名 openssl x509 -in kube-kubelet-$NODENAME.csr -out kube-kubelet-$NODENAME.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca.key -CAcreateserial \\ -req -sha256 -days 7300 \\ -extfile ../kubernetes-ca.conf -extensions req_client rm -f kube-kubelet-$NODENAME.csr chmod 400 kube-kubelet-$NODENAME.key chmod 444 kube-kubelet-$NODENAME.crt # 把证书直接写道配置文件中，客户端不用保留证书了，(`--embed-certs`控制) export KUBECONFIG=kubelet-$NODENAME.conf kubectl config set-cluster default-cluster --server=https://node3:6443 --certificate-authority ../kube-ca.crt --embed-certs kubectl config set-credentials default-auth --client-key kube-kubelet-$NODENAME.key --client-certificate kube-kubelet-$NODENAME.crt --embed-certs kubectl config set-context default-system --cluster default-cluster --user default-auth kubectl config use-context default-system proxy.conf 所有Worker节点的kube-proxy程序可以共用这一个配置文件，所以生成一次即可 注意：证书的CN不要变更 cd ~/ca/kube-ca/kubeconfig # 创建密钥 openssl genrsa -out kube-proxy.key 2048 # 创建证书请求文件 openssl req -new -sha256 \\ -subj \"/C=CN/ST=ShangHai/L=ShangHai/O=net-cc.com/OU=net-cc.com/CN=system:kube-proxy/emailAddress=admin@admin.com\" \\ -key kube-proxy.key -out kube-proxy.csr # 使用kubernetes-ca进行签名 openssl x509 -in kube-proxy.csr -out kube-proxy.crt \\ -CA ../kube-ca.crt -CAkey ../kube-ca","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:3:3","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"3.4 复制证书到各节点 server节点 # 复制kube-apiserver证书/密钥到两个server节点 cd ~/ca/kube-ca/apiserver cp ../kube-ca.crt apiserver.crt apiserver-kubelet-client.crt sa.pub /opt/kubernetes/ssl/ cp ../kube-ca.key apiserver.key apiserver-kubelet-client.key sa.key /opt/kubernetes/ssl/ scp ../kube-ca.crt apiserver.crt apiserver-kubelet-client.crt sa.pub root@node4:/opt/kubernetes/ssl/ scp ../kube-ca.key apiserver.key apiserver-kubelet-client.key sa.key root@node4:/opt/kubernetes/ssl/ # 复制front-proxy-client证书/密钥到两个server节点 cd ~/ca/kube-proxy-ca/front-proxy-client cp front-proxy-client.key front-proxy-client.crt ../front-proxy-ca.crt /opt/kubernetes/ssl/ scp front-proxy-client.key front-proxy-client.crt ../front-proxy-ca.crt root@node4:/opt/kubernetes/ssl/ # 复制controller-manager、scheduler连接配置文件到所有server节点 cd ~/ca/kube-ca/kubeconfig mkdir ~/.kube/ unset KUBECONFIG # 恢复kubectl的环境变量 cp admin.conf ~/.kube/config cp controller-manager.conf scheduler.conf /opt/kubernetes/etc/ scp controller-manager.conf scheduler.conf root@node4:/opt/kubernetes/etc/ node节点 # 复制kubelet配置文件到所有node节点 cd ~/ca/kube-ca/kubeconfig scp kubelet-node1.conf proxy.conf root@node1:/opt/kubernetes/etc/ # 复制kubelet的服务证书 cd ~/ca/kube-ca/kubelet scp ../kube-ca.crt kubelet.crt kubelet.key root@node1:/opt/kubernetes/ssl/ scp ../kube-ca.crt kubelet.crt kubelet.key root@node2:/opt/kubernetes/ssl/ node节点现有文件 tree /opt/kubernetes /opt/kubernetes ├── bin ├── data ├── etc │ └── kubelet-node1.conf # node1才有，node2没有 │ └── proxy.conf | └── conf.d ├── logs └── ssl │ └── kube-ca.crt │ └── kubelet.crt │ └── kubelet.key Master节点现有文件 $ tree /opt/kubernetes /opt/kubernetes ├── bin ├── data ├── etc │ ├── controller-manager.conf │ └── scheduler.conf ├── logs └── ssl ├── apiserver.crt ├── apiserver.key ├── apiserver-kubelet-client.crt ├── apiserver-kubelet-client.key ├── etcd-ca.crt ├── etcd-client.crt ├── etcd-client.key ├── front-proxy-client.crt ├── front-proxy-client.key ├── front-proxy-ca.crt ├── kube-ca.key ├── kube-ca.crt ├── sa.key └── sa.pub ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:3:4","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"4 部署Master Node(主) 下边是一些公共参数，主要是日志配置，节点上的所有程序都调用了 # 公共配置文件Controller Manager、scheduler都调用了 cat \u003e /opt/kubernetes/etc/kube-default.conf\u003c\u003cEOF # k8s所有服务共用配置文件 KUBE_LOG_ARGS=\"--logtostderr=false --log-dir=/opt/kubernetes/logs/ --v=2\" EOF --logtostderr: 设置为false表示将日志写入文件，不写入stderr --log-dir: 日志目录 --v: 日志等级 先安装一个主Master节点，另一个等单节点集群创建成功后在添加 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:4:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"4.1 下载程序 此链接查看最新版 # 下载server端程序 cd /tmp wget https://dl.k8s.io/v1.19.1/kubernetes-server-linux-amd64.tar.gz tar -zxf kubernetes-server-linux-amd64.tar.gz cd kubernetes/server/bin/ cp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin/ # 传到另一个master节点 省的在下载了 scp kube-apiserver kube-scheduler kube-controller-manager root@node4:/opt/kubernetes/bin/ cd /tmp rm -rf kubernetes* ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:4:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"5 部署API Server 主节点上负责提供 Kubernetes API 服务的组件；它是 Kubernetes 控制面的前端。 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:5:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"5. systemd服务 # 添加api-server到systemd服务 cat \u003e /usr/lib/systemd/system/kube-apiserver.service \u003c\u003cEOF [Unit] Description=Kubernetes API Server Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=network.target After=network-online.target Wants=network-online.target [Service] EnvironmentFile=/opt/kubernetes/etc/kube-apiserver.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf User=kube Group=kube ExecStart=/opt/kubernetes/bin/kube-apiserver \\$KUBE_API_ARGS \\$KUBE_LOG_ARGS Restart=on-failure Type=notify LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:5:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"5.2 配置文件 # api-server配置文件, cat \u003e /opt/kubernetes/etc/kube-apiserver.conf\u003c\u003cEOF KUBE_API_ARGS=\"--storage-backend=etcd3 \\\\ --etcd-servers=https://node1:2379,https://node3:2379,https://node2:2379 \\\\ --etcd-cafile=/opt/kubernetes/ssl/etcd-ca.crt \\\\ --etcd-certfile=/opt/kubernetes/ssl/etcd-client.crt \\\\ --etcd-keyfile=/opt/kubernetes/ssl/etcd-client.key \\\\ --bind-address=0.0.0.0 \\\\ --advertise-address=0.0.0.0 \\\\ --secure-port=6443 \\\\ --insecure-port=0 \\\\ --service-cluster-ip-range=10.110.0.0/16 \\\\ --service-node-port-range=30000-32767 \\\\ --allow-privileged=true \\\\ --authorization-mode=RBAC,Node \\\\ --audit-log-maxage=30 \\\\ --audit-log-maxbackup=3 \\\\ --audit-log-maxsize=100 \\\\ --audit-log-path=/opt/kubernetes/logs/k8s-audit.log \\\\ --enable-admission-plugins=NodeRestriction,PodPreset \\\\ --runtime-config=settings.k8s.io/v1alpha1=true \\\\ --client-ca-file=/opt/kubernetes/ssl/kube-ca.crt \\\\ --kubelet-client-certificate=/opt/kubernetes/ssl/apiserver-kubelet-client.crt \\\\ --kubelet-client-key=/opt/kubernetes/ssl/apiserver-kubelet-client.key \\\\ --tls-cert-file=/opt/kubernetes/ssl/apiserver.crt \\\\ --tls-private-key-file=/opt/kubernetes/ssl/apiserver.key \\\\ --service-account-key-file=/opt/kubernetes/ssl/sa.pub \\\\ --enable-bootstrap-token-auth=true \\\\ --token-auth-file=/opt/kubernetes/etc/token.csv \\\\ --requestheader-client-ca-file=/opt/kubernetes/ssl/front-proxy-ca.crt \\\\ --proxy-client-key-file=/opt/kubernetes/ssl/front-proxy-client.key \\\\ --proxy-client-cert-file=/opt/kubernetes/ssl/front-proxy-client.crt \\\\ --requestheader-allowed-names=aggregator,front-proxy-client \\\\ --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\ --requestheader-group-headers=X-Remote-Group \\\\ --requestheader-username-headers=X-Remote-User \\\\ --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \\\\ --enable-aggregator-routing=true\" EOF # 创建token.csv，记住token，等会添加第二个节点需要用到 # 格式：token，用户名，UID，用户组 TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ') cat \u003e /opt/kubernetes/etc/token.csv \u003c\u003c EOF $TOKEN,kubelet-bootstrap,10001,\"system:bootstrappers\" EOF 配置文件说明： --storage-backend: 指定etcd的版本 --etcd-servers: etcd服务的URL --etcd-*file: 连接etcd的证书和密钥 --advertise-address: 集群通告地址 --secure-port: API Server绑定主机安全端口号，默认为6443 --service-cluster-ip-range: Kubernetes集群中Service的虚拟IP地址范围，该IP范围不能与物理机的IP地址有重合。 --service-node-port-range: Kubernetes集群中Service可使用的物理机端口号范围，默认值为30000～32767 --allow-privileged: 启用授权 authorization-mode: 认证授权，启用RBAC授权和节点自管理 audit-log*: 审计日志 --enable-admission-plugins: Kubernetes集群的准入控制设置，各控制模块以插件的形式依次生效。默认启用的有(NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota) --runtime-config: 传递给 apiserver 用于描述运行时配置的键值对集合。 apis/ 键可以被用来打开/关闭特定的 api 版本。apis// 键被用来打开/关闭特定的资源 . api/all 和 api/legacy 键分别用于控制所有的和遗留的 api 版本 --client-ca-file: 对于任何请求，如果存包含client-ca-file中的authorities签名的客户端证书，将会使用客户端证书中的 CommonName 对应的身份进行认证 --kubelet-client-*: apiserver访问kubelet客户端证书 --tls-*-file: apiserver https证书 --service-account-key-file: 服务帐户密钥对 --enable-bootstrap-token-auth: 允许 ‘kube-system’ 命名空间中的 ‘bootstrap.kubernetes.io/token’ 类型密钥可以被用于 TLS 的启动认证 --token-auth-file: 这个文件将被用于通过令牌认证来保护 API 服务的安全端口 备注：apiserver所有参数的官方说明连接 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:5:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"6 部署Controller Manager 在主节点上运行控制器的组件。 从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。 服务帐户和令牌控制器（Service Account \u0026 Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌. ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:6:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"6.1 systemd服务 # 添加controller-manager到systemd服务 cat \u003e /usr/lib/systemd/system/kube-controller-manager.service\u003c\u003cEOF [Unit] Description=Kubernetes Controller Manager Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=kube-apiserver.service Wants=kube-apiserver.service [Service] EnvironmentFile=/opt/kubernetes/etc/kube-controller-manager.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf User=kube Group=kube ExecStart=/opt/kubernetes/bin/kube-controller-manager \\$KUBE_CONTROLLER_MANAGER_ARGS \\$KUBE_LOG_ARGS Restart=on-failure LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:6:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"6.2 配置文件 cat \u003e /opt/kubernetes/etc/kube-controller-manager.conf \u003c\u003c EOF KUBE_CONTROLLER_MANAGER_ARGS=\"--leader-elect=true \\\\ --kubeconfig=/opt/kubernetes/etc/controller-manager.conf \\\\ --authentication-kubeconfig=/opt/kubernetes/etc/controller-manager.conf \\\\ --authorization-kubeconfig=/opt/kubernetes/etc/controller-manager.conf \\\\ --bind-address=0.0.0.0 \\\\ --port=0 \\\\ --cert-dir=/opt/kubernetes/ssl/ \\\\ --allocate-node-cidrs=true \\\\ --configure-cloud-routes=false \\\\ --cloud-provider=external \\\\ --cluster-cidr=10.120.0.0/16 \\\\ --service-cluster-ip-range=10.110.0.0/16 \\\\ --client-ca-file=/opt/kubernetes/ssl/kube-ca.crt \\\\ --root-ca-file=/opt/kubernetes/ssl/kube-ca.crt \\\\ --controllers=*,bootstrapsigner,tokencleaner,-cloud-node-lifecycle \\\\ --cluster-signing-cert-file=/opt/kubernetes/ssl/kube-ca.crt \\\\ --cluster-signing-key-file=/opt/kubernetes/ssl/kube-ca.key \\\\ --cluster-signing-duration=87600h0m0s \\\\ --service-account-private-key-file=/opt/kubernetes/ssl/sa.key \\\\ --requestheader-client-ca-file=/opt/kubernetes/ssl/front-proxy-ca.crt \\\\ --requestheader-allowed-names=aggregator,front-proxy-client \\\\ --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\ --requestheader-group-headers=X-Remote-Group \\\\ --requestheader-username-headers=X-Remote-User \\\\ --use-service-account-credentials=true\" EOF 配置文件说明： --leader-elect：当该组件启动多个时，自动选举（HA） --kubeconfig: 指向 kubeconfig 文件的路径。该文件中包含主控节点位置以及鉴权凭据信息。 --authentication-kubeconfig: kubeconfig 文件的路径名。该文件中包含与某 Kubernetes “核心” 服务器相关的信息，并支持足够的权限以创建 tokenreviews.authentication.k8s.io。此选项是可选的。如果设置为空值，所有令牌请求都会被认作匿名请求，Kubernetes 也不再在集群中查找客户端的 CA 证书信息。 --authorization-kubeconfig: 包含 Kubernetes “核心” 服务器信息的 kubeconfig 文件路径，所包含信息具有创建 subjectaccessreviews.authorization.k8s.io 的足够权限。此参数是可选的。如果配置为空字符串，未被鉴权模块所忽略的请求都会被禁止 --cert-dir: TLS 证书所在的目录。如果提供了–tls-cert-file 和 –tls private-key-file，则将忽略此参数 --allocate-node-cidrs: 为 Pod 分配和设置子网掩码 --configure-cloud-routes: 决定是否由 –allocate-node-cidrs 所分配的 CIDR 要通过云驱动程序来配置。 --cloud-provider: 云服务的提供者。external表示没有对应的提供者（驱动） --cluster-cidr: Kubernetes集群中pod的IP地址范围 --service-cluster-ip-range: Kubernetes集群中Service的虚拟IP地址范围，该IP范围不能与物理机的IP地址有重合。 --client-ca-file: 对于所有能够提供客户端证书的请求，若该证书由 client-ca-file 中所给机构之一签署，则该请求会被成功认证为客户端证书中 CommonName 所给的实体 --root-ca-file: 服务账号的令牌Secret中会包含此根证书机构 --controllers：要启用的控制器列表。* 表示启用所有默认启用的控制器, 这里我禁用了云检测 --cluster-signing-cert-file/--cluster-signing-key-file：自动为kubelet颁发证书的CA，与apiserver保持一致 --cluster-signing-duration: 自动为kubelet颁发证书的有效期 --service-account-private-key-file: 服务帐户密钥对 --use-service-account-credentials: 为每个控制器单独使用服务账号凭据。 备注：Controller Manager的所有参数说明连接 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:6:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"7 部署scheduler 主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:7:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"7.1 systemd服务 # 添加scheduler到systemd服务 cat \u003e /usr/lib/systemd/system/kube-scheduler.service\u003c\u003cEOF [Unit] Description=Kubernetes Scheduler Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=kube-apiserver.service Wants=kube-apiserver.service [Service] EnvironmentFile=/opt/kubernetes/etc/kube-scheduler.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf ExecStart=/opt/kubernetes/bin/kube-scheduler \\$KUBE_SCHEDULER_ARGS \\$KUBE_LOG_ARGS User=kube Group=kube Restart=on-failure LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:7:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"7.2 配置文件 cat \u003e /opt/kubernetes/etc/kube-scheduler.conf\u003c\u003cEOF KUBE_SCHEDULER_ARGS=\"--leader-elect=true \\\\ --cert-dir=/opt/kubernetes/ssl/ \\\\ --config=/opt/kubernetes/etc/kube-scheduler.yaml \\\\ --authentication-kubeconfig=/opt/kubernetes/etc/scheduler.conf \\\\ --authorization-kubeconfig=/opt/kubernetes/etc/scheduler.conf \" EOF 配置文件说明： --leader-elect：当该组件启动多个时，自动选举（HA） --cert-dir: TLS 证书所在的目录。如果提供了–tls-cert-file 和 –tls private-key-file，则将忽略此参数 --config: 指配置文件的路径。命令行参数会覆盖此文件中的值。 --authentication-kubeconfig: 指向具有足够权限以创建 subjectaccessreviews.authorization.k8s.io 的 ‘core’ kubernetes 服务器的 kubeconfig 文件 备注: 所有scheduler的参数说明连接 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:7:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"8 修复文件权限 mkdir -p /var/run/kubernetes /usr/libexec/kubernetes echo 'd /var/run/kubernetes 0755 kube kube -' \u003e\u003e /usr/lib/tmpfiles.d/kubernetes.conf chown kube:kube -R /var/run/kubernetes /usr/libexec/kubernetes /opt/kubernetes/{etc,logs,ssl,data} restorecon -R /opt/kubernetes /usr/libexec/kubernetes /var/run/kubernetes ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:8:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"9 启动服务 systemctl start kube-apiserver.service systemctl start kube-controller-manager.service systemctl enable kube-apiserver.service systemctl enable kube-controller-manager.service ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:9:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"10 生成scheduler配置文件 需要先启动API server # 生成kube-scheduler.yaml默认文件 /opt/kubernetes/bin/kube-scheduler \\ --authentication-kubeconfig=/opt/kubernetes/etc/scheduler.conf \\ --authorization-kubeconfig=/opt/kubernetes/etc/scheduler.conf \\ --kubeconfig=/opt/kubernetes/etc/scheduler.conf \\ --authentication-tolerate-lookup-failure=false \\ --write-config-to /opt/kubernetes/etc/kube-scheduler.yaml # 启动scheduler systemctl start kube-scheduler.service systemctl enable kube-scheduler.service ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:10:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"11 查看集群状态 由于我的ca管理和kubectl程序都是安装在node3上的，所以在node3上操作 # 复制kubectl的配置文件 mkdir ~/.kube/ cp ~/ca/kube-ca/kubeconfig/admin.conf ~/.kube/config export KUBECONFIG=\"~/.kube/config\" kubectl get cs NAME STATUS MESSAGE ERROR scheduler Healthy ok controller-manager Healthy ok etcd-2 Healthy {\"health\":\"true\"} etcd-1 Healthy {\"health\":\"true\"} etcd-0 Healthy {\"health\":\"true\"} ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:11:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"12 授权APIserver访问kubelet –kubelet-client-*参数调用证书的CN是system:masters所以用户就是system:masters, system:masters用户默认绑定到了集群管理员了，不要轻易使用哦~~ kubectl create clusterrolebinding system:kubelet-api-admin \\ --clusterrole=system:kubelet-api-admin \\ --user=system:masters ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:12:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"13 授权kubelet创建csr 刚刚生成的toke文件中的用户组是system:bootstrappers， 把用户组和RBAC预定义规则system:node-bootstrapper进行绑定既可以授权kubelet通过apiserver管理证书了 kubectl create clusterrolebinding system:kubelet-bootstrap \\ --clusterrole system:node-bootstrapper \\ --group system:bootstrappers ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:13:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"14 部署Worker Node 注意：一个节点（node1）的kubelet使用手动生成的密钥/证书, 一个（node2）上kubelet的密钥证书是由TLS Bootstrapping管理的，所以要两个节点上的kubelet配置是不一样的，其他都一样。 下边是一些公共参数，主要是日志配置，节点上的所有程序都调用了 cat \u003e /opt/kubernetes/etc/kube-default.conf\u003c\u003cEOF # k8s所有服务共用配置文件 KUBE_LOG_ARGS=\"--logtostderr=false --log-dir=/opt/kubernetes/logs/ --v=2\" EOF --logtostderr: 设置为false表示将日志写入文件，不写入stderr --log-dir: 日志目录 --v: 日志等级 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:14:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"14.1 安装docker Kubernetes 支持多个容器运行环境: Docker、 containerd、cri-o、 rktlet 以及任何实现 Kubernetes CRI (容器运行环境接口),我才用docker，毕竟常用 参考我之前写的一篇文章来安装docker 两个worker节点上安装配置都一样 注意docker的配置文件如下： mkdir -p /etc/docker cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"registry-mirrors\":[\"https://t88fp3u4.mirror.aliyuncs.com\"], \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"iptables\": false, \"ip-forward\": false, \"ip-masq\": false, \"userland-proxy\": false, \"selinux-enabled\": true, \"storage-driver\": \"overlay2\", \"storage-opts\": [ \"overlay2.override_kernel_check=true\" ] } EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:14:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"14.2 下载程序文件 此链接查看最新版 cd /tmp wget https://dl.k8s.io/v1.19.1/kubernetes-node-linux-amd64.tar.gz tar -zxf kubernetes-node-linux-amd64.tar.gz cd kubernetes/node/bin/kubelet sudo cp kubelet kube-proxy /opt/kubernetes/bin/ # 传到另一各节点上，以免再次下载 scp kubelet kube-proxy root@node2:/opt/kubernetes/bin/ cd /tmp rm -rf kubernetes* ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:14:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"15 部署kubelet(node1) 一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。 这里我先写在node1节点上通过手动管理证书的方式来启动kubelet，另一个等会在说 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:15:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"15.1 systemd服务 # 设置kubelet的systemd服务 cat \u003e /usr/lib/systemd/system/kubelet.service \u003c\u003cEOF [Unit] Description=Kubernetes Kubelet Server Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=docker.service Wants=docker.service [Service] WorkingDirectory=/opt/kubernetes/data/ EnvironmentFile=/opt/kubernetes/etc/kube-kubelet.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf ExecStart=/opt/kubernetes/bin/kubelet \\$KUBE_LOG_ARGS \\$KUBE_KUBELET_ARGS Restart=on-failure [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:15:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"15.2 配置文件 # 注意--kubeconfig的参数，文件调用本机的文件 cat \u003e /opt/kubernetes/etc/kube-kubelet.conf\u003c\u003cEOF KUBE_KUBELET_ARGS=\"\\\\ --kubeconfig=/opt/kubernetes/etc/kubelet-$HOSTNAME.conf \\\\ --hostname-override=$HOSTNAME \\\\ --network-plugin=cni \\\\ --config=/opt/kubernetes/etc/kube-kubelet.yaml \\\\ --dynamic-config-dir=/opt/kubernetes/etc/conf.d \\\\ --cert-dir=/opt/kubernetes/ssl \\\\ --pod-infra-container-image=951021/pause\" EOF # 注意cgroupDriver修改容器的cgroup一样，默认为：cgroupfs cat \u003e /opt/kubernetes/etc/kube-kubelet.yaml\u003c\u003cEOF kind: KubeletConfiguration apiVersion: kubelet.config.k8s.io/v1beta1 cgroupDriver: systemd tlsCertFile: /opt/kubernetes/ssl/kubelet.crt tlsPrivateKeyFile: /opt/kubernetes/ssl/kubelet.key clusterDNS: - 10.110.0.2 clusterDomain: cluster.local authentication: x509: clientCAFile: /opt/kubernetes/ssl/kube-ca.crt anonymous: enabled: false webhook: enabled: true authorization: mode: Webhook webhook: cacheAuthorizedTTL: 0s cacheUnauthorizedTTL: 0s evictionHard: imagefs.available: 15% memory.available: 100Mi nodefs.available: 10% nodefs.inodesFree: 5% staticPodPath: /opt/kubernetes/data/manifests failSwapOn: false hairpinMode: hairpin-veth EOF 配置文件说明： --kubeconfig:该文件将用于获取 kubelet 的客户端证书。如果 –kubeconfig 指定的文件不存在，则使用引导 kubeconfig 从 API 服务器请求客户端证书。成功后，将引用生成的客户端证书和密钥的 kubeconfig 文件写入 –kubeconfig 所指定的路径。客户端证书和密钥文件将存储在 –cert-dir 指向的目录中。 --hostname-override: 设置本Node的名称。 --network-plugin: 启用CNI --config: kubelet 将从该文件加载其初始配置。该路径可以是绝对路径，也可以是相对路径。相对路径从 kubelet 的当前工作目录开始。省略此参数则使用内置的默认配置值。命令行参数会覆盖此文件中的配置。 --cert-dir: LS 证书所在的目录。如果设置了 –tls-cert-file 和 –tls-private-key-file，则该设置将被忽略。（默认值为 “/var/lib/kubelet/pki”） --pod-infra-container-image: 指定基础设施镜像，Pod 内所有容器与其共享网络和 IPC 命名空间。仅当容器运行环境设置为 docker 时，此特定于 docker 的参数才有效。（默认值为 “k8s.gcr.io/pause:3.1”）默认的由于某种不可描述的原因，无法访问，自己想办法吧。 备注：所有kubelet参数说明连接 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:15:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"15.3 安装一些需要用到的工具 yum install conntrack-tools libnetfilter_cthelper libnetfilter_cttimeout libnetfilter_queue socat-y ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:15:3","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16 部署kubelet(node2) 这个节点的kubelet的密钥证书是由TLS Bootstrapping管理的 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16.1 systemd服务 # 设置kubelet的systemd服务 cat \u003e /usr/lib/systemd/system/kubelet.service \u003c\u003cEOF [Unit] Description=Kubernetes Kubelet Server Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=docker.service Wants=docker.service [Service] WorkingDirectory=/opt/kubernetes/data/ EnvironmentFile=/opt/kubernetes/etc/kube-kubelet.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf ExecStart=/opt/kubernetes/bin/kubelet \\$KUBE_LOG_ARGS \\$KUBE_KUBELET_ARGS Restart=on-failure [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16.2 配置文件 # 注意--kubeconfig的参数，文件调用本机的文件 cat \u003e /opt/kubernetes/etc/kube-kubelet.conf\u003c\u003cEOF KUBE_KUBELET_ARGS=\"\\\\ --kubeconfig=/opt/kubernetes/etc/kubelet-$HOSTNAME.conf \\\\ --bootstrap-kubeconfig=/opt/kubernetes/etc/bootstrap.conf \\\\ --hostname-override=$HOSTNAME \\\\ --dynamic-config-dir=/opt/kubernetes/etc/conf.d \\\\ --network-plugin=cni \\\\ --config=/opt/kubernetes/etc/kube-kubelet.yaml \\\\ --cert-dir=/opt/kubernetes/ssl \\\\ --pod-infra-container-image=registry.cn-shanghai.aliyuncs.com/net-cc/pause\" EOF # 注意cgroupDriver修改容器的cgroup一样，默认为：cgroupfs cat \u003e /opt/kubernetes/etc/kube-kubelet.yaml\u003c\u003cEOF kind: KubeletConfiguration apiVersion: kubelet.config.k8s.io/v1beta1 cgroupDriver: systemd tlsCertFile: /opt/kubernetes/ssl/kubelet.crt tlsPrivateKeyFile: /opt/kubernetes/ssl/kubelet.key clusterDNS: - 10.110.0.2 clusterDomain: cluster.local authentication: x509: clientCAFile: /opt/kubernetes/ssl/kube-ca.crt anonymous: enabled: false webhook: cacheTTL: 0s enabled: true authorization: mode: Webhook webhook: cacheAuthorizedTTL: 0s cacheUnauthorizedTTL: 0s evictionHard: imagefs.available: 15% memory.available: 100Mi nodefs.available: 10% nodefs.inodesFree: 5% failSwapOn: false hairpinMode: hairpin-veth EOF 这里新增加了一个参数--bootstrap-kubeconfig用来首次启动向apiserver申请证书 bootstrap-kubeconfig文件生成方法： 由于我的kubectl安装在master 节点(node3)上的，所以需要在master节点上生成，然后复制到worker节点的/opt/kubernetes/etc/目录 cd ~/ca/kube-ca/kubeconfig KUBE_APISERVER=\"https://node3:6443\" # apiserver IP:PORT TOKEN=\"c47ffb939f5ca36231d9e3121a252940\" # 与token.csv里保持一致 # 生成bootstrap配置文件 kubectl config set-cluster kubernetes --certificate-authority=/opt/kubernetes/ssl/kube-ca.crt --embed-certs=true --server=${KUBE_APISERVER} --kubeconfig=bootstrap.conf kubectl config set-credentials system:bootstrappers --token=${TOKEN} --kubeconfig=bootstrap.conf kubectl config set-context default --cluster=kubernetes --user=system:bootstrappers --kubeconfig=bootstrap.conf kubectl config use-context default --kubeconfig=bootstrap.conf # 传到node2节点 scp bootstrap.conf root@node2:/opt/kubernetes/etc/bootstrap.conf ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16.3 启动服务 restorecon -R /opt/kubernetes systemctl daemon-reload systemctl start kubelet systemctl enable kubelet ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:3","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16.4 批准kubelet证书申请并加入集群 # 查看kubelet证书请求 kubectl get csr NAME AGE SIGNERNAME REQUESTOR CONDITION node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A 6m3s kubernetes.io/kube-apiserver-client-kubelet kubelet-bootstrap Pending # 批准申请 kubectl certificate approve node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A # 查看节点 kubectl get node NAME STATUS ROLES AGE VERSION k8s-master NotReady \u003cnone\u003e 7s v1.18.3 注：由于网络插件还没有部署，节点会没有准备就绪 NotReady ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:4","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"16.5 安装一些需要用到的工具 yum install conntrack-tools -y 注意：这里的--kubeconfig指向的配置文件是空的，等会会自动生成 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:16:5","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"17 部署kube-proxy kube-proxy 是集群中每个节点上运行的网络代理,实现 Kubernetes Service 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。 两个worker节点上安装配置都一样 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:17:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"17.1 systemd服务 # 设置kube-proxy的systemd服务 cat \u003e /usr/lib/systemd/system/kube-proxy.service \u003c\u003cEOF [Unit] Description=Kubernetes Kube-Proxy Server Documentation=https://github.com/GoogleCloudPlatform/kubernetes After=network.target After=network-online.target Wants=network-online.target [Service] WorkingDirectory=/opt/kubernetes/data/ EnvironmentFile=/opt/kubernetes/etc/kube-proxy.conf EnvironmentFile=/opt/kubernetes/etc/kube-default.conf ExecStart=/opt/kubernetes/bin/kube-proxy \\$KUBE_PROXY_ARGS \\$KUBE_LOG_ARGS Restart=on-failure [Install] WantedBy=multi-user.target EOF ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:17:1","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"17.2 配置文件 cat \u003e /opt/kubernetes/etc/kube-proxy.conf\u003c\u003cEOF KUBE_PROXY_ARGS=\"--config=/opt/kubernetes/etc/kube-proxy.yaml\" EOF # 生成配置文件 /opt/kubernetes/bin/kube-proxy \\ --kubeconfig=/opt/kubernetes/etc/proxy.conf \\ --write-config-to=/opt/kubernetes/etc/kube-proxy.yaml # 修改配置文件的以下几个地方 hostnameOverride: $HOSTNAME ......... clusterCIDR: =10.120.0.0/16 ........ ipvs: ........ scheduler: \"rr\" ........ mode: \"ipvs\" 配置文件说明： --config: 配置文件的路径。 --kubeconfig: 包含授权信息的 kubeconfig 文件的路径（master 位置由 master 标志设置） --write-config-to: 将配置值写入此文件并退出程序 注意：所有配置参数说明连接 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:17:2","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"18 文件权限 restorecon -R /opt/kubernetes ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:18:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"19 启动服务 sudo systemctl daemon-reload sudo systemctl start kubelet.service sudo systemctl start kube-proxy.service sudo systemctl enable kubelet.service sudo systemctl enable kube-proxy.service ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:19:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"20 部署CNI网络 通过给Kubelet传递–network-plugin=cni命令行选项来选择CNI插件。Kubelet从–cni-conf-dir（默认是/etc/cni/net.d）读取文件并使用该文件中的CNI配置来设置每个pod的网络。CNI配置文件必须与CNI规约匹配，并且配置引用的任何所需的CNI插件都必须存在于–cni-bin-dir（默认是/opt/cni/bin）。 如果这个目录中有多个CNI配置文件，kubelet将会使用按文件名的字典顺序排列的第一个作为配置文件。 除了配置文件指定的CNI插件外，Kubernetes还需要标准的CNIlo插件，最低版本是0.2.0。 查看最新版本 安装CNI二进制文件 # 两个Worker Node上都需要安装 mkdir -p /opt/cni/bin/ VERSION=v0.8.7 cd /tmp curl -L https://github.com/containernetworking/plugins/releases/download/${VERSION}/cni-plugins-linux-amd64-${VERSION}.tgz -o cni-plugins-linux-amd64-${VERSION}.tgz tar -zxvf cni-plugins-linux-amd64-${VERSION}.tgz -C /opt/cni/bin/ scp -r /opt/cni/bin/ root@node2:/opt/cni/bin/ rm -f cni-plugins-linux-amd64-${VERSION}.tgz 安装CNI网络插件flannel flannel我部署到kube集群里边了，没有单独每个Worker Node部署 # 在master节点操作，因为master节点安装了kubectl客户端程序和配置 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml PODIP=10.120.0.0/16 # pod的ip地址，即controller-manager控制器设置的cluster-cidr地址 sed -i 's|10.244.0.0/16|'\"$PODIP\"'|g' kube-flannel.yml kubectl apply -f kube-flannel.yml Master Node(备) 和Master Node主配置一样，不在叙述 负载均衡 ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:20:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"部署nginx 安装nginx 在两个master node上安装 yum install -y nginx 配置nginx 使用nginx的4层负载均衡，主备一样 setsebool -P nis_enabled 1 # 修改selinux权限 cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak cat \u003e\u003e /etc/nginx/nginx.conf \u003c\u003cEOF # 四层负载均衡，为两台Master apiserver组件提供负载均衡 stream { log_format main '\\$remote_addr \\$upstream_addr - [\\$time_local] \\$status \\$upstream_bytes_sent'; access_log /var/log/nginx/k8s.access.log main; upstream k8s-apiserver { server 192.168.122.12:6443; # Master1 APISERVER IP:PORT server 192.168.122.13:6443; # Master2 APISERVER IP:PORT } server { listen 8443; proxy_pass k8s-apiserver; } } EOF 启动nginx systemctl start nginx systemctl enable nginx ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:21:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"部署keepalived 安装keepalived 在两个master node上安装keepalived即可（一主一备） yum install -y keepalived mkdir -p /etc/keepalived master节点1(node3)配置文件 mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.back cat \u003e /etc/keepalived/keepalived.conf\u003c\u003cEOF ! Configuration File for keepalived global_defs { router_id keepalive-master } vrrp_script check_apiserver { # 检测脚本路径 script \"/etc/keepalived/check-nginx.sh\" # 多少秒检测一次 interval 3 # 失败的话权重-2 weight -2 fail 1 } vrrp_instance VI-kube-master { state MASTER # 定义节点角色 interface ens3 # 网卡名称 virtual_router_id 68 priority 100 # 启用单播模式~ unicast_src_ip 192.168.122.12 unicast_peer { 192.168.122.13 } dont_track_primary advert_int 3 authentication { auth_type PASS auth_pass net-cc } virtual_ipaddress { # 自定义虚拟ip 192.168.122.2 } track_script { check_apiserver } } EOF master节点2(node4)配置文件 mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.back cat \u003e /etc/keepalived/keepalived.conf\u003c\u003cEOF ! Configuration File for keepalived global_defs { router_id keepalive-backup } vrrp_script check_apiserver { script \"/etc/keepalived/check-nginx.sh\" interval 3 weight -5 fail 1 } vrrp_instance VI-kube-master { state BACKUP interface ens32 virtual_router_id 68 priority 95 unicast_src_ip 192.168.122.13 unicast_peer { 192.168.122.12 } dont_track_primary advert_int 3 authentication { auth_type PASS auth_pass net-cc } virtual_ipaddress { 192.168.122.2 } track_script { check_apiserver } } EOF 两个节点都创建以下脚本文件 cat \u003e /etc/keepalived/check-nginx.sh\u003c\u003cEOF #!/bin/bash #检查ngin进程是否存在 counter=\\$(ps -C nginx --no-heading|wc -l) if [ \"\\${counter}\" = \"0\" ]; then #尝试启动一次ngnx,停止5秒后再次检测 systemctl restart nginx sleep 5 counter=\\$(ps -C nginx --no-heading|wc -l) if [ \"\\${counter}\"=\"0\" ]; then #如果启动没成功,就杀掉keepave触发主备切换 systemctl stop nginx exit 2 fi fi EOF chmod +x /etc/keepalived/check-nginx.sh 启动keepalived systemctl enable keepalived \u0026\u0026 service keepalived start 测试 curl -k https://192.168.122.2:6443/version { \"major\": \"1\", \"minor\": \"19\", \"gitVersion\": \"v1.19.1\", \"gitCommit\": \"206bcadf021e76c27513500ca24182692aabd17e\", \"gitTreeState\": \"clean\", \"buildDate\": \"2020-09-09T11:18:22Z\", \"goVersion\": \"go1.15\", \"compiler\": \"gc\", \"platform\": \"linux/amd64\" } ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:22:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"测试 关闭主节点Nginx，测试VIP是否漂移到备节点服务器。 # 在Nginx Master执行 pkill nginx pkill nginx # 在Nginx Backup，ip addr命令查看已成功绑定VIP ip addr 访问负载均衡器测试 找K8s集群中任意一个节点，使用curl查看K8s版本测试，使用VIP访问： curl -k https://192.168.122.2:6443/version { \"major\": \"1\", \"minor\": \"18\", \"gitVersion\": \"v1.18.3\", \"gitCommit\": \"2e7996e3e2712684bc73f0dec0200d64eec7fe40\", \"gitTreeState\": \"clean\", \"buildDate\": \"2020-05-20T12:43:34Z\", \"goVersion\": \"go1.13.9\", \"compiler\": \"gc\", \"platform\": \"linux/amd64\" } ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:23:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"修改所有Worker Node连接LB VIP 虽然我们增加了Master2和负载均衡器，但是我们是从单Master架构扩容的，也就是说目前所有的Node组件连接都还是Master1，如果不改为连接VIP走负载均衡器，那么Master还是单点故障。 因此接下来就是要改所有Node组件配置文件 所有Worker Node执行： sed -i 's#192.168.122.12#k8s.api#g' /opt/kubernetes/etc/* sed -i 's#node3#k8s.api#g' /opt/kubernetes/etc/* systemctl restart kubelet systemctl restart kube-proxy 检查节点状态： kubectl get node NAME STATUS ROLES AGE VERSION k8s-master Ready \u003cnone\u003e 34h v1.18.3 k8s-master2 Ready \u003cnone\u003e 101m v1.18.3 k8s-node1 Ready \u003cnone\u003e 33h v1.18.3 k8s-node2 Ready \u003cnone\u003e 33h v1.18.3 至此，一套完整的 Kubernetes 高可用集群就部署完成了！ PS：如果你是在公有云上，一般都不支持keepalived，那么你可以直接用它们的负载均衡器产品（内网就行，还免费~），架构与上面一样，直接负载均衡多台Master kube-apiserver即可！ ","date":"2020-09-20","objectID":"/posts/linux-software/kubernetes/03-install-k8s/:24:0","tags":["kubernetes"],"title":"二进制方式安装K8S","uri":"/posts/linux-software/kubernetes/03-install-k8s/"},{"categories":["linux software"],"content":"通过二进制方式安装高可用ETCD集群，并采用动态添加一个节点","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"1 节点信息 IP地址 主机名称 类型 系统 192.168.122.10 node1 etcd centos7 192.168.122.11 node2 etcd centos7 192.168.122.12 node3 etcd centos8 ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:1:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"2 节点创建etcd账户和防火墙放行 # 创建用户和目录 groupadd -r etcd # -k MAIL_DIR=/dev/null参数不创建此用户的mail目录 useradd -s /sbin/nologin -d /var/lib/etcd -g etcd -c \"etcd user\" -r -K MAIL_DIR=/dev/null etcd mkdir -p /opt/etcd/{ssl,etc,log,bin,data} # 设置权限 chown etcd:etcd -R /opt/etcd/{data,etc,log,ssl} chmod 700 /opt/etcd/data restorecon -R /opt/etcd # 开通防火墙端口 firewall-cmd --add-service=etcd-server --permanent firewall-cmd --add-service=etcd-client --permanent firewall-cmd --reload ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:2:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"3 下载etcd二进制文件 在所有节点上下载ETCD的二进制文件 # etcd的版本 ETCD_VER=v3.4.13 # 通过github下载 GITHUB_URL=https://github.com/etcd-io/etcd/releases/download DOWNLOAD_URL=${GITHUB_URL} # 删除旧的程序压缩包，如果有的话 rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz rm -rf /tmp/etcd-download-test \u0026\u0026 mkdir -p /tmp/etcd-download-test # 解压 curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz tar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1 # 复制etcd执行程序到/opt/etcd/bin目录下 cp /tmp/etcd-download-test/etcd* /opt/etcd/bin/ # 恢复SElinux权限，如果有的话 restorecon -R /opt/etcd # 清理 rm -rf /tmp/etcd-download-test/ rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:3:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"4 创建system服务 在所有节点上都需要创建 cat \u003e /usr/lib/systemd/system/etcd.service\u003c\u003cEOF [Unit] Description=Etcd Server After=network.target After=network-online.target Wants=network-online.target [Service] WorkingDirectory=/opt/etcd/data EnvironmentFile=/opt/etcd/etc/config User=etcd # set GOMAXPROCS to number of processors ExecStart=/opt/etcd/bin/etcd Restart=on-failure RestartSec=5 LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF # 配置etcd的配置文件位置 echo 'ETCD_CONFIG_FILE=\"/opt/etcd/etc/etcd.conf\"' \u003e /opt/etcd/etc/config ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:4:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"5 初始集群 先使用node1和node2创建初始集群，等会在动态添加node3节点 ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:5:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"5.2 创建配置文件 以下配置文件中选项的官方描述：https://etcd.io/docs/v3.4.0/op-guide/configuration node1配置文件 cat \u003e /opt/etcd/etc/etcd.conf\u003c\u003cEOF name: 'node1' data-dir: '' wal-dir: '' # 定义此节点在集群中和其他节点通信的URL listen-peer-urls: http://192.168.122.10:2380 # 定义对外提供服务的URL listen-client-urls: http://192.168.122.10:2379,http://127.0.0.1:2379 # 告诉其他节点，此节点使用哪个URL和你通讯。所以其他集群必须在网络层面可以到达这个地址。URL可以包含域名 initial-advertise-peer-urls: http://192.168.122.10:2380 # 告诉集群中其他节点，此节点可以提供服务的URL advertise-client-urls: http://192.168.122.10:2379 # 集群节点之间互相通信的URL，可以动态添加 initial-cluster: node1=http://192.168.122.10:2380,node3=http://192.168.122.11:2380 # 加入集群的token initial-cluster-token: 'k8s' # 初始集群状态，new是新建集群的时候采用，如果是加入已有集群，此处必须是existing initial-cluster-state: 'new' enable-v2: true enable-pprof: true debug: false logger: zap EOF node2配置文件 cat \u003e /opt/etcd/etc/etcd.conf\u003c\u003cEOF name: 'node1' data-dir: '' wal-dir: '' # 定义此节点在集群中和其他节点通信的URL listen-peer-urls: http://192.168.122.11:2380 # 定义对外提供服务的URL listen-client-urls: http://192.168.122.11:2379,http://127.0.0.1:2379 # 告诉其他节点，此节点使用哪个URL和你通讯。所以其他集群必须在网络层面可以到达这个地址。URL可以包含域名 initial-advertise-peer-urls: http://192.168.122.11:2380 # 告诉集群中其他节点，此节点可以提供服务的URL advertise-client-urls: http://192.168.122.11:2379 # 集群节点之间互相通信的URL，可以动态添加 initial-cluster: node1=http://192.168.122.10:2380,node3=http://192.168.122.11:2380 # 加入集群的token initial-cluster-token: 'k8s' # 初始集群状态，new是新建集群的时候采用，如果是加入已有集群，此处必须是existing initial-cluster-state: 'new' enable-v2: true enable-pprof: true debug: false logger: zap EOF ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:5:1","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"5.3 启动ETCD服务 先启动node1，然后在启动node2，每个节点的目录权限别忘记更改 systemctl daemon-reload systemctl start etcd.service systemctl enable etcd.service ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:5:2","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"5.4 测试etcd # 由于参数太多，所以添加etcdctl参数环境变量 cat \u003e\u003e ~/.bashrc\u003c\u003cEOF export ETCDCTL_API=3 export ETCDCTL_ENDPOINTS=http://192.168.122.10:2379,http://192.168.122.11:2379 PATH=$PATH:$HOME/bin:/opt/etcd/bin export PATH EOF source ~/.bashrc etcdctl endpoint health --write-out=table ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:5:3","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"6 动态添加集群成员 前边已经配置了两个成员的etcd集群，etcd集群成员少于三个没有冗余性的，下边我们动态添加一个成员。在已经添加到etcd集群的服务器（node1）通过etcdctl客户端动态添加成员 etcdctl member add node3 --peer-urls=http://192.168.122.12:2380 # 以上命令执行成功会返回新集群的配置参数，如下，记录下来，等会修改集群配置 ETCD_NAME=\"node3\" ETCD_INITIAL_CLUSTER=\"node1=http://192.168.122.10:2380,node2=http://192.168.122.11:2380,node3=https://192.168.122.12:2380\" ETCD_INITIAL_ADVERTISE_PEER_URLS=\"https://192.168.122.12:2380\" ETCD_INITIAL_CLUSTER_STATE=\"existing\" ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:6:0","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"6.1 修改配置文件 根据上边命令回显，node3添加配置如下，参数解析和node1一样 cat \u003e /opt/etcd/etc/etcd.conf\u003c\u003cEOF name: $ETCD_NAME data-dir: '' wal-dir: '' listen-peer-urls: http://192.168.122.12:2380 listen-client-urls: http://192.168.122.12:2379,http://127.0.0.1:2379 initial-advertise-peer-urls: $ETCD_INITIAL_ADVERTISE_PEER_URLS advertise-client-urls: http://192.168.122.12:2379 initial-cluster: $ETCD_INITIAL_CLUSTER initial-cluster-token: 'k8s' initial-cluster-state: 'existing' enable-v2: true enable-pprof: true debug: false logger: zap EOF ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:6:1","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"6.2 启动新节点 # 启动服务 systemctl daemon-reload systemctl start etcd.service systemctl enable etcd.service ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:6:2","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"6.3 测试etcd etcdctl endpoint health --write-out=table ","date":"2020-09-06","objectID":"/posts/linux-software/kubernetes/02-install-etcd/:6:3","tags":["kubernetes"],"title":"etcd安装与配置","uri":"/posts/linux-software/kubernetes/02-install-etcd/"},{"categories":["linux software"],"content":"使用openssl生成支持SAN扩展的证书笔记","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"OpenSSL 是一个免费开源的库，它提供了构建数字证书的命令行工具，其中一些可以用来自建 Root CA。 ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:0:0","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"1 安装openssl sudo yum install openssl openssl-libs ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:1:0","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"2 自建Root CA 首先找到一个放置证书的文件夹，比如 ~/ca 下，下方的测试也在改目录下，如果你要更换其他目录，记得替换下文中的目录地址 ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:2:0","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"2.1 设定文件架构，并配置openssl设置 创建目录 mkdir -p ~/ca/{certs,crl,newcerts,private} cd ~/ca chmod 700 private touch index.txt echo 1000 \u003e serial cp /etc/pki/tls/openssl.cnf ./ 修改openssl.cnf配置 # 更改openssl.cnf的以下参数 [ CA_default ] dir = /home/cc/ca certs = $dir/certs certificate = $dir/certs/cacert.pem crl = $dir/crl/cacrl.pem private_key = $dir/private/cakey.pem crl_dir = $dir/crl database = $dir/index.txt new_certs_dir = $dir/newcerts serial = $dir/serial crlnumber = $dir/crlnumber # 在openssl.cnf的末尾添加以下配置 [ v3_intermediate_ca ] # Extensions for a typical intermediate CA (`man x509v3_config`). subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:true, pathlen:0 keyUsage = critical, digitalSignature, cRLSign, keyCertSign ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:2:1","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"2.2 创建Root CA Key # 注意，此处提供了-aes256参数用来加密密钥，所以必须输入密码 cd ~/ca openssl genrsa -aes256 -out private/cakey.pem 4096 chmod 400 private/cakey.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:2:2","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"2.3 创建Root CA cert cd ~/ca # 需要输入root CA key的密码 openssl req -config openssl.cnf -key private/cakey.pem -new -x509 -days 14500 -sha256 -extensions v3_ca -out certs/cacert.pem chmod 444 certs/cacert.pem 以上命令需要提供CA Key的密码，就是刚刚创建CA key的密码，还需要提供Country Name(C)、State(ST)、Locality(L)、Organization(O)、Organizational Unit(OU)、Common Name(CN)、电子邮件地址(emailAddress )，注意：Common Name不可以重复，例： Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:ShangHai Locality Name (eg, city) [Default City]:ShangHai Organization Name (eg, company) [Default Company Ltd]:Net Cc Organizational Unit Name (eg, section) []:Net Cc Certificate Authority Common Name (eg, your name or your server's hostname) []:Net Cc Root CA Email Address []: ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:2:3","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"2.4 验证证书 验证命令 $ openssl x509 -noout -text -in certs/ca.cert 主要看以下参数是否正确：数字签名（Signature Algorithm）、有效时间（Validity）、主体（Issuer）、公钥（Public Key）、X509v3 扩展，openssl config 中配置了 v3_ca，所以会生成此项 ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:2:4","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3 自建Intermediate CA ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:0","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.1 设定文件架构，并配置openssl设置 创建目录 mkdir -p intermediate/{certs,crl,newcerts,private,csr} cd ~/ca/intermediate chmod 700 private touch index.txt echo 1000 \u003e serial echo 1000 \u003e crlnumber cp ../openssl.cnf ./ 修改openssl.cnf配置 # 更改openssl.cnf的以下配置 [ CA_default ] dir = /home/cc/ca/intermediate [ policy_match ] organizationName = supplied ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:1","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.2 创建Intermediate CA Key cd ~/ca/intermediate # 注意，此处提供了-aes256参数用来加密密钥，所以必须输入密码，等会生成CA证书和签名的时候需要用到这个密码 openssl genrsa -aes256 -out private/cakey.pem 4096 chmod 400 private/cakey.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:2","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.3 创建Intermediate CA CSR，注意 Common Name 不要与 Root CA 的一样 cd ~/ca/intermediate # 需要输入intermediate CA key的密码 openssl req -config openssl.cnf -new -sha256 -key private/cakey.pem -out csr/ca.csr 以上命令需要提供Intermediate CA Key的密码和一些名字，注意：Common Name不可以重复，例： Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:ShangHai Locality Name (eg, city) [Default City]:ShangHai Organization Name (eg, company) [Default Company Ltd]:Net Cc Organizational Unit Name (eg, section) []:Net Cc Certificate Authority Common Name (eg, your name or your server's hostname) []:Net Cc Intermediate CA Email Address []: ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:3","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.4 使用root ca进行签名 cd ~/ca # 使用root CA的openssl.cnf文件，需要输入root CA 密钥的密码 openssl ca -config openssl.cnf -extensions v3_intermediate_ca -days 7300 -notext -md sha256 -in intermediate/csr/ca.csr -out intermediate/certs/cacert.pem chmod 444 intermediate/certs/cacert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:4","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.5 验证 cd ~/ca/intermediate openssl x509 -noout -text -in certs/cacert.pem openssl verify -CAfile ../certs/cacert.pem certs/cacert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:5","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"3.6 创建证书链，将 root cert 和 intermediate cert 合并到一起 cd ~/ca/intermediate cat ../certs/cacert.pem certs/cacert.pem \u003e certs/ca-chaincert.pem # 验证证书链 openssl verify -CAfile certs/ca-chaincert.pem certs/cacert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:3:6","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4 创建带有SAN扩展的证书 ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:0","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.1 创建san.cnf配置文件 [ req_san ] subjectKeyIdentifier = hash basicConstraints = CA:FALSE authorityKeyIdentifier = keyid,issuer:always keyUsage = critical, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth,serverAuth subjectAltName = @alt_names # SAN调用了alt_names所以我们下边要添加一个alt_names # SAN地址设置，DNS是域名，ip是IP地址 [ alt_names ] DNS.1 = net-cc.com DNS.2 = *.net-cc.com DNS.3 = localhost IP.1 = 127.0.0.1 ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:1","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.2 创建server/client Key cd ~/ca/intermediate/ # 此处我们没有添加加密密码，如果有加密的话，服务器可能无法解密使用key验证。。 openssl genrsa -out private/net-cc.com.key.pem 2048 chmod 400 private/net-cc.com.key.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:2","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.3 创建证书请求文件CSR cd ~/ca/intermediate/ openssl req -config openssl.cnf -key private/net-cc.com.key.pem -new -sha256 -out csr/net-cc.com.csr 需要提供Country Name(C)、State(ST)、Locality(L)、Organization(O)、Organizational Unit(OU)、Common Name(CN)、电子邮件地址(emailAddress )，注意：Common Name不可以重复，例： Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:ShangHai Locality Name (eg, city) [Default City]:ShangHai Organization Name (eg, company) [Default Company Ltd]:net-cc.com Organizational Unit Name (eg, section) []:www.net-cc.com Common Name (eg, your name or your server's hostname) []:net-cc.com Email Address []: ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:3","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.4 使用Intermediate CA进行签名 cd ~/ca/intermediate/ openssl ca -config openssl.cnf -extfile san.cnf -extensions req_san -days 3650 -notext -md sha256 -in csr/net-cc.com.csr -out certs/net-cc.com.cert.pem chmod 444 certs/net-cc.com.cert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:4","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.5 验证 openssl verify -CAfile certs/ca-chaincert.pem certs/net-cc.com.cert.pem openssl x509 -noout -text -in certs/net-cc.com.cert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:5","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"4.6 Server/Client的证书密钥文件位置 key: ~/ca/intermediate/private/net-cc.com.key.pem cert: ~/ca/intermediate/certs/net-cc.com.cert.pem CA Cert: ~/ca/intermediate/certs/ca-chaincert.pem ","date":"2020-09-06","objectID":"/posts/linux-software/04-openssl/:4:6","tags":["linux"],"title":"openssl证书管理","uri":"/posts/linux-software/04-openssl/"},{"categories":["linux software"],"content":"通过官方仓库安装nginx的最新版本，并做简单配置，并提供静态网页","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"通过官方仓库来安装nginx的最新版本，做简单配置，并提供静态网页 ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:0:0","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"1 安装nginx 采用官方仓库安装比较简单快速，没必要在纠结选择那种，如果是内网环境，无法上网，可以通过一台可以上网的服务器，下载rpm包上传到提供服务的服务器上来安装。 ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:1:0","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"1.1 添加官方仓库 sudo su cat \u003e /etc/yum.repos.d/nginx.repo\u003c\u003cEOF [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true EOF ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:1:1","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"1.2 安装nginx yum install nginx -y systemctl enable nginx systemctl start nginx ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:1:2","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"2 更改配置 nginx的配置存放在/etc/nginx目录下边, nginx.conf 是全局的一些配置，config.d目录是网站配置，一般建议一个域名对应一个文件 备份/etc/nginx/conf.d/default.conf sudo cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak 修改/etc/nginx/conf.d/default.conf cat \u003e /etc/nginx/conf.d/default.conf\u003c\u003cEOF # 使用http协议访问带www的网址，跳转到https协议的带www的网址上 server { listen 80; server_name www.net-cc.com; return 301 https://www.net-cc.com$request_uri; } # 使用http协议访问不带www的网址，跳转到https协议的带www的网址上 server { listen 80; server_name net-cc.com; return 301 https://www.net-cc.com$request_uri; } # 使用https协议访问不带www的网址，跳转到https协议的带www的网址上 server { listen 443 ssl; server_name net-cc.com; return 301 https://www.net-cc.com$request_uri; # SSL证书配置 ssl_certificate /etc/nginx/ssl/net-cc.com.pem; # 证书 ssl_certificate_key /etc/nginx/ssl/net-cc.com.key; # 证书的密钥 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 协议 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 加密方式 ssl_session_timeout 5m; } # https协议的带www的网址（主）配置 server { listen 443 ssl; server_name www.net-cc.com; # 网站的域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # SSL证书配置 ssl_certificate /etc/nginx/ssl/www.net-cc.com.pem; # 证书 ssl_certificate_key /etc/nginx/ssl/www.net-cc.com.key; # 证书的密钥 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 协议 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 加密方式 ssl_session_timeout 5m; location / { root /usr/share/nginx/html; index index.html index.htm; } error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # # 拒绝访问.git目录 location ~ /\\.git { deny all; } } EOF ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:2:0","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"3 申请https证书 我是通过阿里云申请的证书，可以使用Let’s Encrypt申请免费三个月的证书 ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:3:0","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"4 下载网站的静态文件 git clone git@gitlab.com:net-cc/net-cc.com.git ","date":"2020-09-05","objectID":"/posts/linux-software/nginx/01-install-nginx/:4:0","tags":["nginx"],"title":"Nginx的安装和简单配置","uri":"/posts/linux-software/nginx/01-install-nginx/"},{"categories":["linux software"],"content":"使用centos系统如何安装docker容器，采用的是通过yum源方式进行安装，主要为了方便快速","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"1 开启网络转发和PNAT centos6 参考这里：https://blog.csdn.net/qianye_111/article/details/78987161 firewall-cmd --add-masquerade --permanent --zone=public # 更改防火墙开启PNAT firewall-cmd --reload # 开启转发 cat \u003e /etc/sysctl.d/99-kubernetes-cri.conf \u003c\u003cEOF net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-ip6tables = 1 EOF sysctl -p /etc/sysctl.d/99-kubernetes-cri.conf cat /proc/sys/net/ipv4/ip_forward # 查看是否开启了ip转发，如果返回1表示开启了 ","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/:1:0","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"2 通过yum安装docker-ce 使用仓库安装，方便，也可以二进制安装，编译的话不建议了，时间就是金钱，我的朋友。阿里云镜像站介绍 # step 1: 安装必要的一些系统工具 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Step 2: 添加软件源信息 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # Step 3: 更新并安装 Docker-CE sudo yum makecache fast sudo yum -y install docker-ce # Step 4: 开启Docker服务 sudo systemctl docker start # 注意： # 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。 # vim /etc/yum.repos.d/docker-ce.repo # 将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1 # # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # yum list docker-ce.x86_64 --showduplicates | sort -r # Loading mirror speeds from cached hostfile # Loaded plugins: branch, fastestmirror, langpacks # docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable # docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable # docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable # Available Packages # Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos) # sudo yum -y install docker-ce-[VERSION] ","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/:2:0","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"3 配置docker网络 如果要docker内容器要固定ip地址，需要创建一个network # 把ip改为相应的即可 docker network create --attachable --driver bridge --gateway 192.168.243.1 --subnet 192.168.243.1/24 --ipam-driver default mybridge 不同主机之间的docker相互访问，首先要确定主机与主机之间是否互联，不能经过nat，然后在主机配置到docker网段的路由即可 # linux配置路由，注意替换ip地址 # centos7 firewall-cmd --add-masquerade --permanent --zone=public firewall-cmd --reload ip route add 192.168.240.0/20 via 192.168.250.4 ip route del 192.168.240.0/20 via 192.168.250.4 # 删除路由 # centos 6 sysctl -w net.ipv4.ip_forward=1 route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41 or route add -net 192.168.1.0/24 eth1 route del -net 10.20.30.40 netmask 255.255.255.248 eth0 # 删除路由 # windows配置路由 route -p add 157.0.0.0 MASK 255.0.0.0 157.55.80.1 METRIC 3 IF 2 # 修改删除路由 route CHANGE 157.0.0.0 MASK 255.0.0.0 157.55.80.5 METRIC 2 IF 2 # 修改 route delete 157.0.0.0 # 删除 ","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/:3:0","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"4 docker配置ip、log和存储驱动 mkdir -p /etc/docker # 创建配置文件，配置docker默认网桥的IP地址为192.168.66.1/24，使用163和中国科技大学的镜像站 cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\" ], \"exec-opts\": [ \"native.cgroupdriver=systemd\" ], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"bip\": \"192.168.66.1/24\", \"ipv6\": false, \"iptables\": false, \"ip-masq\": false, \"dns\": [ \"223.5.5.5\", \"223.6.6.6\" ], \"dns-search\":[ \"net-cc.com\" ], \"storage-driver\": \"overlay2\", \"storage-opts\": [ \"overlay2.override_kernel_check=true\" ] } EOF mkdir -p /etc/systemd/system/docker.service.d ","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/:4:0","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"5 docker daemon.json配置文件格式 官方的完整配置样式，需要根据你的需要修改 { \"allow-nondistributable-artifacts\": [], \"api-cors-header\": \"\", \"authorization-plugins\": [], \"bip\": \"\", \"bridge\": \"\", \"cgroup-parent\": \"\", \"cluster-advertise\": \"\", \"cluster-store\": \"\", \"cluster-store-opts\": {}, \"containerd\": \"/run/containerd/containerd.sock\", \"containerd-namespace\": \"docker\", \"containerd-plugin-namespace\": \"docker-plugins\", \"data-root\": \"\", \"debug\": true, \"default-address-pools\": [ { \"base\": \"172.30.0.0/16\", \"size\": 24 }, { \"base\": \"172.31.0.0/16\", \"size\": 24 } ], \"default-cgroupns-mode\": \"private\", \"default-gateway\": \"\", \"default-gateway-v6\": \"\", \"default-runtime\": \"runc\", \"default-shm-size\": \"64M\", \"default-ulimits\": { \"nofile\": { \"Hard\": 64000, \"Name\": \"nofile\", \"Soft\": 64000 } }, \"dns\": [], \"dns-opts\": [], \"dns-search\": [], \"exec-opts\": [], \"exec-root\": \"\", \"experimental\": false, \"features\": {}, \"fixed-cidr\": \"\", \"fixed-cidr-v6\": \"\", \"group\": \"\", \"hosts\": [], \"icc\": false, \"init\": false, \"init-path\": \"/usr/libexec/docker-init\", \"insecure-registries\": [], \"ip\": \"0.0.0.0\", \"ip-forward\": false, \"ip-masq\": false, \"iptables\": false, \"ip6tables\": false, \"ipv6\": false, \"labels\": [], \"live-restore\": true, \"log-driver\": \"json-file\", \"log-level\": \"\", \"log-opts\": { \"cache-disabled\": \"false\", \"cache-max-file\": \"5\", \"cache-max-size\": \"20m\", \"cache-compress\": \"true\", \"env\": \"os,customer\", \"labels\": \"somelabel\", \"max-file\": \"5\", \"max-size\": \"10m\" }, \"max-concurrent-downloads\": 3, \"max-concurrent-uploads\": 5, \"max-download-attempts\": 5, \"mtu\": 0, \"no-new-privileges\": false, \"node-generic-resources\": [ \"NVIDIA-GPU=UUID1\", \"NVIDIA-GPU=UUID2\" ], \"oom-score-adjust\": -500, \"pidfile\": \"\", \"raw-logs\": false, \"registry-mirrors\": [], \"runtimes\": { \"cc-runtime\": { \"path\": \"/usr/bin/cc-runtime\" }, \"custom\": { \"path\": \"/usr/local/bin/my-runc-replacement\", \"runtimeArgs\": [ \"--debug\" ] } }, \"seccomp-profile\": \"\", \"selinux-enabled\": false, \"shutdown-timeout\": 15, \"storage-driver\": \"\", \"storage-opts\": [], \"swarm-default-advertise-addr\": \"\", \"tls\": true, \"tlscacert\": \"\", \"tlscert\": \"\", \"tlskey\": \"\", \"tlsverify\": true, \"userland-proxy\": false, \"userland-proxy-path\": \"/usr/libexec/docker-proxy\", \"userns-remap\": \"\" } ","date":"2020-08-30","objectID":"/posts/linux-software/kubernetes/01-install-docker/:5:0","tags":["kubernetes"],"title":"centos安装docker","uri":"/posts/linux-software/kubernetes/01-install-docker/"},{"categories":["linux software"],"content":"本文介绍了通过iptables来配置linux防火墙,最新的centos8 已经不适用此文档","date":"2020-08-30","objectID":"/posts/linux-software/02-iptables/","tags":["linux"],"title":"iptbales学习笔记","uri":"/posts/linux-software/02-iptables/"},{"categories":["linux software"],"content":"本文介绍了通过iptables来配置linux防火墙,最新的centos8 已经不适用此文档 ","date":"2020-08-30","objectID":"/posts/linux-software/02-iptables/:0:0","tags":["linux"],"title":"iptbales学习笔记","uri":"/posts/linux-software/02-iptables/"},{"categories":["linux software"],"content":"1 iptables介绍 包过滤型的防火墙，隔离工具；工作于主机或网络边缘，对于进出本主机或本网络的报文根据事先定义的检查规则作匹配检测，对于能够被规则匹配到的报文作出相应处理的组件； iptables 的底层是用内核的netfilter 来进行包过滤的 netfilter hook function: prerouting input output forward postrouting 链（内置）：PREROUTING、INPUT、FORWARD、INPUT、POSTROUTING 功能： filter：过滤，防火墙； nat: network address translation；用于修改源IP或目标IP，也可以改端口； mangle: 拆解报文，做出修改，并重新封装起来； raw: 关闭nat表上启用的连接追踪机制； 功能\u003c–链： raw：PREROUTING， OUTPUT mangle：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat：PREROUTING，[INPUT]OUTPUT，POSTROUTING filter：INPUT，FORWARD，OUTPUT 报文流向： 流入本机：PREROUTING –\u003e INPUT 由本机流出：OUTPUT –\u003e POSTROUTING 转发：PREROUTING –\u003e FORWARD –\u003e POSTROUTING 路由功能发生的时刻： 报文进入本机后： 判断目标主机是？ 报文离开本机之前： 判断经由哪个接口送往下一站？ 规则 组成部分：根据规则匹配条件来尝试匹配报文，一旦匹配成功，就由规则定义的处理动作作出处理； 匹配条件： 基本匹配条件：内建 扩展匹配条件：由扩展模块定义； 处理动作： 基本处理动作：内建 扩展处理动作：由扩展模块定义； 自定义处理机制：自定义链 iptables的链：内置链和自定义链 内置链：对应于hook function 自定义链接：用于内置链的扩展和补充，可实现更灵活的规则管理机制； 添加规则时的考量点： 要实现哪种功能：判断添加到哪个表上； 报文流经的路径：判断添加到哪个链上； 链：链上的规则次序，即为检查的次序；因此，隐含一定的应用法则： 同类规则（访问同一应用），匹配范围小的放上面； 不同类的规则（访问不同应用），匹配到报文频率较大的放在上面； 将那些可由一条规则描述的多个规则合并起来； 设置默认策略； ","date":"2020-08-30","objectID":"/posts/linux-software/02-iptables/:1:0","tags":["linux"],"title":"iptbales学习笔记","uri":"/posts/linux-software/02-iptables/"},{"categories":["linux software"],"content":"2 iptables命令 高度模块化，由诸多扩展模块实现其检查条件或处理动作的定义；模块位置/usr/lib64/xtables/， IPv6模块libip6t_开头，IPv4模块libipt_, libxt_开头 iptables [-t table] {-A|-C|-D} chain rule-specification iptables [-t table] -I chain [rulenum] rule-specification iptables [-t table] -R chain rulenum rule-specification iptables [-t table] -D chain rulenum iptables [-t table] -S [chain [rulenum]] iptables [-t table] {-F|-L|-Z} [chain [rulenum]] [options...] iptables [-t table] -N chain iptables [-t table] -X [chain] iptables [-t table] -P chain target iptables [-t table] -E old-chain-name new-chain-name rule-specification = [matches...] [target] match = -m matchname [per-match-options] target = -j targetname [per-target-options] 规则格式： iptables [-t table] COMMAND chain [PARAMETERS] [-m matchname [per-match-options]] -j targetname [per-target-options] -t table: raw, mangle, nat, [filter] COMMAND: 链管理: -N：new, 自定义一条新的规则链； -X： delete，删除自定义的规则链； 注意：仅能删除 用户自定义的 引用计数为0的 空的 链； -P：Policy，设置默认策略；对filter表中的链而言，其默认策略有： ACCEPT：接受 DROP：丢弃 REJECT：拒绝 -E：重命名自定义链；引用计数不为0的自定义链不能够被重命名，也不能被删除； 规则管理: -A：append，追加； -I：insert, 插入，要指明位置，省略时表示第一条； -D：delete，删除； (1) 指明规则序号； (2) 指明规则本身； -R：replace，替换指定链上的指定规则； -F：flush，清空指定的规则链； -Z：zero，置零； iptables的每条规则都有两个计数器： (1) 匹配到的报文的个数； (2) 匹配到的所有报文的大小之和； 查看 -L：list, 列出指定鏈上的所有规则； -n：numberic，以数字格式显示地址和端口号； -v：verbose，详细信息； -vv, -vvv -x：exactly，显示计数器结果的精确值； --line-numbers：显示规则的序号； chain： 内置链 PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING 自定义链 匹配条件： 基本匹配条件(PARAMETERS)： 无需加载任何模块，由iptables/netfilter自行提供； [!]取反 [!] -s, --source address[/mask][,...]：检查报文中的源IP地址是否符合此处指定的地址或范围； [!] -d, --destination address[/mask][,...]：检查报文中的目标IP地址是否符合此处指定的地址或范围；所有地址：0.0.0.0/0 [!] -p, --protocol protocol: tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh or [all] [!] -i, --in-interface name：数据报文流入的接口；只能应用于数据报文流入的环节，只能应用于PREROUTING，INPUT和FORWARD链； [!] -o, --out-interface name：数据报文流出的接口；只能应用于数据报文流出的环节，只能应用于FORWARD、OUTPUT和POSTROUTING链； 扩展匹配(matchname) 隐式扩展 在使用-p选项指明了特定的协议时，无需再同时使用-m选项指明扩展模块的扩展机制； tcp: [!] --source-port, --sport port[:port]：匹配报文的源端口；可以是端口范围； [!] --destination-port,--dport port[:port]：匹配报文的目标端口；可以是端口范围； [!] --tcp-flags mask comp mask is the flags which we should examine, written as a comma-separated list，例如 SYN,ACK,FIN,RST comp is a comma-separated list of flags which must be set，例如SYN 例如：“--tcp-flags SYN,ACK,FIN,RST SYN”表示，要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0； [!] --syn：用于匹配第一次握手，相当于”--tcp-flags SYN,ACK,FIN,RST SYN“； udp: [!] --source-port, --sport port[:port]：匹配报文的源端口；可以是端口范围； [!] --destination-port,--dport port[:port]：匹配报文的目标端口；可以是端口范围； icmp: [!] --icmp-type {type[/code]|typename} echo-request：8/0 echo-reply：0/0 显式扩展 必须使用-m选项指明要调用的扩展模块的扩展机制； multiport: 以离散或连续的 方式定义多端口匹配条件，最多15个； [!] --source-ports,--sports port[,port|,port:port]...：指定多个源端口； [!] --destination-ports,--dports port[,port|,port:port]...：指定多个目标端口； $ sudo iptables -I INPUT -d 172.16.0.7 -p tcp -m multiport --dports 22,80,139,445,3306 -j ACCEPT iprange: 以连续地址块的方式来指明多IP地址匹配条件； [!] --src-range from[-to] [!] --dst-range from[-to] $ sudo iptables -I INPUT -d 172.16.0.7 -p tcp -m multiport --dports 22,80,139,445,3306 -m iprange --src-range 172.16.0.61-172.16.0.70 -j REJECT time: 如果数据包到达时间/日期在给定范围内，则匹配。 --timestart hh:mm[:ss] --timestop hh:mm[:ss] [!] --weekdays day[,day...] [!] --monthdays day[,day...] --datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] --datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] --kerneltz：使用内核配置的时区而非默认的UTC； string: 此模块使用某种模式匹配策略来匹配给定的字符串, 只对明文编码的字符串可以匹配 --algo {bm|kmp} # 检测模式 [!] --string pattern # 字符串 [!] --hex-string pattern # 字符串hex --from offset # 从数据包的那里开始检测 --to offset # 到数据包的那里检测结束 $ sudo iptables -I OUTPUT -m string --algo bm --string \"gay\" -j REJECT connlimit: 允许您限制每个客户端IP地址（或客户端地址块）到服务器的并行连接数。 --connlimit-upto n # 上限，小于等于N --connlimit-above n # 下限，大于N $ sudo iptables -I INPUT -d 172.16.0.7 -p tcp --syn --dport 22 -m connlimit --connlimit-above 2 -j REJECT limit: 该模块使用令牌桶过滤器以有限的速率匹配。 限制本机某tcp服务接收新请求的速率：–syn, -m limit # 限制每(秒|分钟|小时|天）可以生成多少个令牌 --limit rate[/second|/minute|/hour|/day] # 令牌桶最大可以存","date":"2020-08-30","objectID":"/posts/linux-software/02-iptables/:2:0","tags":["linux"],"title":"iptbales学习笔记","uri":"/posts/linux-software/02-iptables/"},{"categories":["Virtual Machines"],"content":"介绍使用libvirt来管理Linux的KVM虚拟机，并介绍virsh命令","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"使用libvirt来管理Linux的KVM虚拟机，主要使用virsh命令 kvm学习笔记 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:0:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"1 libvirt 配置文件 libvirt 的默认配置文件在：/etc/libvirt libvirt 的默认工作区在：/var/cache/libvirt ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:1:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"1.1 libvirt 远程配置 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:1:1","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"1.2 Guest xml配置文件介绍 验证xml文件virt-xml-validate /path/to/XML/file 官方文档 主要介绍xml中每一行的意思，当然也可以手动创建适合您的domain xml文件然后通过virsh define 命令来定义一个虚拟机,然后通过virsh start来启动虚拟机 通用根配置文件 \u003cdomain type='kvm' id='1'\u003e \u003cname\u003eMyGuest\u003c/name\u003e \u003cuuid\u003e4dea22b3-1d52-d8f3-2516-782e98ab3fa0\u003c/uuid\u003e \u003cgenid\u003e43dc0cf8-809b-4adb-9bea-a9abb5f3d90e\u003c/genid\u003e \u003ctitle\u003eA short description - title - of the domain\u003c/title\u003e \u003cdescription\u003eSome human readable description\u003c/description\u003e \u003cmetadata\u003e \u003capp1:foo xmlns:app1=\"http://app1.org/app1/\"\u003e..\u003c/app1:foo\u003e \u003capp2:bar xmlns:app2=\"http://app1.org/app2/\"\u003e..\u003c/app2:bar\u003e \u003c/metadata\u003e ...... \u003cdomain\u003e 根元素domain有两个属性，type代表虚拟机的管理程序，有kvm，xen,qemu,lxc和kqemu；id代表正在运行的虚拟机唯一整数标识符，非活动的虚拟机没有id name 虚拟机的名称，同一个物理机器唯一 uuid 全局唯一标识符，格式必须符合RFC 4122，如果在定义/创建新domain时省略，则会生成随机UUID。也可以通过sysinfo规范提供uuid genid 和uuid元素一样。 title 可选元素title为虚拟机的简短描述，不应包含任何换行符。 description description元素为虚拟机的详细描述，libvirt不以任何方式使用此数据，它可以包含用户想要的任何信息 metadata（没理解） The metadata node can be used by applications to store custom metadata in the form of XML nodes/trees. Applications must use custom namespaces on their XML nodes/trees, with only one top-level element per namespace (if the application needs structure, they should have sub-elements to their namespace element) 虚拟机系统启动相关 有许多不同的方法可以启动虚拟机，每种方法各有利弊。 bios启动 通过BIOS引导可用于支持完全虚拟化的虚拟机管理程序。在这种情况下，BIOS具有引导顺序优先级（软盘，硬盘，cdrom，网络），用于确定获取/查找引导映像的位置。 ........... \u003cos\u003e \u003ctype arch='x86_64' machine='pc-q35-rhel7.5.0'\u003ehvm\u003c/type\u003e \u003cloader readonly='no' secure='no' type='rom'\u003e/usr/share/OVMF/OVMF_CODE.fd\u003c/loader\u003e \u003cnvram\u003e/home/cc/.config/libvirt/qemu/nvram/windows_VARS.fd\u003c/nvram\u003e \u003cboot dev='hd'/\u003e \u003cboot dev='cdrom'/\u003e \u003cbootmenu enable='yes' timeout='3000'/\u003e \u003csmbios mode='sysinfo'/\u003e \u003cbios useserial='yes' rebootTimeout='0'/\u003e \u003c/os\u003e ........... type type元素的内容指定要在虚拟机中引导的操作系统的类型, hvm为借助qemu-kvm完全虚拟化，arch属性指定虚拟化的CPU架构，machine属性指定虚拟化的机器类型；可以通过 virsh capabilities 查看type元素支持的内容 loader loader可选元素的内容是指定虚拟机守护进程的绝对路径，用户辅助虚拟机的创建。有两个可选属性，readonly: 值有yes|no，标记镜像是可写或者只读；type: 值有rom|pflash，以什么方式引导镜像，pflash可以加载UEFI镜像，secure控制是否开启安全启动 nvram nvram可选元素的表示虚拟uefi固件的文件位置，在qemu.conf文件中定义了，template属性会覆盖掉qemu.conf中的关于nvram的相应配置 boot boot元素的值：fd,hd,cdrom或network中的一个，用于指定引导设备，可以重复多次来设置设备引导的优先级列表，在磁盘等设备的部分也可以控制引导顺序，并且优先级比这里的高，也是官方推荐的。 bootmenu bootmenu元素定义是否在guest启动时启用交互式启动菜单，如果未指定，将使用管理程序的默认值 smbios smbios元素定义如何填充guest虚拟机中可见的SMBIOS信息，必选属性mode的值:emulate(让虚拟机管理程序生成所有值)，host(从主机的SMBIOS值复制块0和块1中的所有块，除了UUID)或者sysinfo(使用sysinfo元素中的值) bios bios元素定义bios启动的设置，uefi启动无效。useserial属性：启用或禁用串行图形适配器，允许用户在串行端口上查看BIOS消息，需要定义串口; rebootTimeout属性：引导失败后多久重新启动，毫秒为单位，最大65535，-1禁止启动 主机启动加载器 使用其他的启动加载器来启动IOS文件，安装系统或者直接启动系统，例如 pygrubXen： \u003cbootloader\u003e/usr/bin/pygrub\u003c/bootloader\u003e \u003cbootloader_args\u003e--append single\u003c/bootloader_args\u003e bootloader: bootloader元素的内容提供了主机OS​​中引导加载程序可执行文件的完全路径。将运行此引导加载程序以选择要引导的内核 bootloader_args: 可选bootloader_args元素参数传递给引导加载程序 直接内核启动 安装新的客户操作系统时，直接从存储在主机操作系统中的内核和initrd启动通常很有用，允许将命令行参数直接传递给安装程序。此功能通常适用于para和full虚拟客户端 参考官网:https://libvirt.org/formatdomain.html#elementsOSKernel linux容器启动 使用基于容器的虚拟化而不是内核/启动映像启动域 参考官网:https://libvirt.org/formatdomain.html#elementsOSContainer SMBIOS系统信息 一些管理程序允许控制向客户呈现的系统信息（例如，SMBIOS字段可以由管理程序填充并通过客户机中的dmidecode命令进行检查）。可选sysinfo元素涵盖所有此类信息。 参照官网:https://libvirt.org/formatdomain.html#elementsSysinfo CPU分配 \u003cdomain\u003e ...... \u003cvcpu placement='static' cpuset=\"1-4,^3,6\" current=\"1\"\u003e2\u003c/vcpu\u003e \u003cvcpus\u003e \u003cvcpu id='0' enabled='yes' hotpluggable='no' order='1'/\u003e \u003cvcpu id='1' enabled='no' hotpluggable='yes'/\u003e \u003c/vcpus\u003e ...... \u003c/domain\u003e vcpu 此元素的内容定义为guest虚拟机操作系统分配的最大虚拟CPU数，必须介于1和虚拟机管理程序支持的最大值之间。最好不要超过实际CPU数量 cpuset 可选属性cpuset是以逗号分隔的物理CPU编号列表，默认情况下可以固定域进程和虚拟CPU。该列表中的每个元素可以是单个CPU编号，一系列CPU编号，^后跟要从先前范围中排除的CPU编号。 current 是否应启用最少CPU数量 placement placement(分配模式):static|auto，如果通过cpuset来指定CPU个数，必须为static。如果placement为static，cpuset并没有指定，将固定所有可用物理CPU vcpus 控制各个vCPU的状态 ID属性指定libvirt使用的vcpu id,注意：某些情况下，guest中现实的vcpu id可能和libvirt不一样，有效范围从0到由vcpu定义的最大CPU减一 enable属性表示控制vcpu的状态，值：yes|no；当值为no的时候开机不启用这个CPU，必须启动热插拔。 hotpluggable属性控制在启动时启用CPU的情况下，是否可以对指定的vCPU进行热插拔。请注意，所有已禁用的vCPU必须是可热插拔的(即enable是no的hotpluggable必","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:1:2","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"2 管理工具 这里直接写命令的常用方式，涉及到的参数的意义，可从优化和介绍kvm里详细查看 默认的KVM虚拟机工作目录为/var/lib/libvirt，配置文件目录/etc/libvirt/qemu,主机名称+xml结尾的文件即其相关虚拟机的配置文件，需要修改其配置，也可以直接修改xml文件实现（不建议）。其中autostart目录定义的配置文件会随主机一起启动，而network定义了虚拟机使用桥接网络时的网关网卡的相关配置。 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:2:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"2.1 qemu-img 创建镜像文件，参考磁盘存储 qemu-img create -f qcow2 node1.qcow2 10G # 创建大小为10G，qcow2格式的镜像文件 qemu-img info node1.qcow2 # 查看镜像信息 qemu-img convert -f raw -o qcow2 node1.img node1.qcow2 # 更改镜像格式 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:2:1","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"2.2 virsh virsh 是一个用于监控系统程序和客户机虚拟机器的命令行接口（CLI）工具。virsh 命令行工具建立在 libvirt 管理 API，并作为可选择的一个运行方式来替代 qemu-kvm 命令和图形界面的 virt-manager 应用。无特权的用户以只读的方式使用 virsh 命令；有根用户权限的用户可以使用该命令的所有功能。virsh 是一个对虚拟环境的管理任务进行脚本化的理想工具。另外，virsh 工具是 guest 操作系统 域的一个主要管理接口，可以用于创造、暂停和关闭“域”，或罗列现有域。这一工具作为 libvirt-client 软件包中的一部分被安装。 KVM虚拟机依靠两个主要文件来启动，一个是img文件，一个是xml配置文件 安装 dnf install libvirt-client or yum install libvirt-client 命令常用方式 virsh define node1.xml # 导入虚拟机配置（xml格式）（这个虚拟机还不是活动的) virsh create node1.xml # 创建虚拟机（创建后，虚拟机立即执行，成为活动主机） virsh start node1 # 开启node1虚拟机 virsh suspend node1 # 暂停虚拟机（不释放资源） virsh resume node1 # 启动暂停的虚拟机 virsh shutdown node1 # 正常关闭虚拟机 virsh destroy node1 # 强制关闭虚拟机 virsh dominfo node1 # 查看虚拟机的基本信息 virsh domname 2 # 查看序号为2的虚拟机别名 virsh domid node1 # 查看虚拟机的序号 virsh domstate node1 # 查看虚拟机的当前状态 virsh list --all # 查看所有虚拟机 virsh domstate node1 # 查看虚拟机的xml配置（可能和定义虚拟机时的配置不同，因为当虚拟机启动时，需要给虚拟机分配id号、uuid、vnc端口号等等） virsh setmem node1 512000 # 给不活动的虚拟机设置内存大小 virsh setvcpus node1 4 # 给不活动的虚拟机设置CPU个数 virsh destroy node1 # 销毁虚拟机，不删除虚拟机配置 virsh undefine node1 # 删除虚拟机配置 virsh dumpxml node1 # 显示虚拟机的xml配置 virsh edit node1 # 编辑xml配置文件 virsh vncdisplay node1 # 获取虚拟机的vnc连接端口 存储池来管理存储 virsh pool-define-as kvm_images dir - - - - \"/home/data/kvm/pool\" # 定义存储池 virsh pool-build kvm_images # 建立基于文件夹的存储池 virsh pool-start kvm_images # 使存储池生效 virsh pool-info kvm_images # 查看存储池详情 virsh pool-list --all # 查看所有存储池 # 创建完存储池后，就可以通过创建卷的方法来创建虚拟机的磁盘 virsh vol-create-as kvm_images node1.qcow2 10G --format qcow2 # 创建卷 virsh pool-refresh kvm_images # 刷新存储池 virsh vol-info kvm_images # 查看存储池里边的存储卷信息 virsh vol-info node1.qcow2 kvm_images # 查看存储池里边单独一个卷的信息 virsh vol-dumpxml node1.qcow2 kvm_images # 查看存储池里边的一个卷的详细信息 虚拟机备份 virsh save --bypass-cache node1 /var/lib/libvirt/save/node1_1.save --running # 备份 virsh restore /var/lib/libvirt/save/node1_1.save --bypass-cache --running # 还原 虚拟机快照 如果要使用kvm的快照功能，就必须使用qcow2的磁盘格式，而raw只支持内存快照，如果不是，请修改 virsh snapshot-create node1 node1.snap1 # 创建快照 virsh snapshot-revert node1 node1.snap1 # 恢复快照 virsh snapshot-list node1 # 查看快照 virsh snapshot-delete node1 node1.snap1 # 删除快照 虚拟机迁移 KVM虚拟机依靠两个主要文件来启动，一个是img文件，一个是xml配置文件,因此迁移的时候，可以直接迁移这两个文件就能实现静态迁移。如果img文件存放在共享存储，则更为方便，只用迁移xml配置文件，就可以实现静态迁移。 当然，virsh命令也可以迁移虚拟机，不过要求目标主机与当前主机的应用环境须保持一致，其命令格式如下： virsh migrate --live node1 qemu+tcp//destnationip/system tcp://destnationip 通过xml创建虚拟机，xml写法请参考xml ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:2:2","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"2.3 virt-viewer 远程连接工具，支持vnc和spice ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:2:3","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"2.4 其他工具 请查看redhat官方介绍其他工具 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:2:4","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"3 磁盘\u0026存储配置 存储池和储存卷 “存储池 ”（storage pool）即一个由 “libvirt” 管理的文件、目录或储存设备，其目的是为虚拟机提供储存空间。存储池被分隔为存储 “卷 ”（volume），可以用来存储虚拟机镜像或附加到虚拟机作为额外额存储。多个客机可共享同一储存池，允许储存资源得到更好分配 储存池进一步划分为“储存卷 ”（storage volume）。储存卷是物理分区、LVM 逻辑卷、基于文件的磁盘镜像及其它由 libvirt 控制的储存形式的抽象层。不论基于何种硬件，储存卷会作为本地储存设备呈现给虚拟机。 个人理解为，存储池就是从本地硬盘或网络硬盘划分出来一个区域给虚拟机 guest 系统使用的存储空间，每个卷相对guest系统来说就是一块硬盘 本地存储池 本地储存池直接连接到主机服务器。它们包括本地目录、直接连接的磁盘、物理分区和本地设备上的 LVM 卷组，因为本地存储池不支持实时迁移，所以它可能不适用于某些生产环境。 网络存储池 网络储存池包括在网络上使用标准协议共享的储存设备。使用 virt-manager 在主机间进行虚拟机的迁移需要网络储存，但是当使用 virsh 迁移时，它是可选的。网络储存池由 libvirt 进行管理。 主机存储 磁盘镜像可以储存在一系列和主机相连的本地或远程存储中。(可以存储在本地或者网络磁盘中) KVM虚拟机的磁盘镜像从存储方式来看分为两种：存储于文件系统，直接使用使用裸设备。 镜像文件(存储在文件系统中) 镜像文件储存在主机文件系统中。它可以储存在本地文件系统中，如 ext4 或 xfs；或网络文件系统中，如 NFS 创建一个镜像文件给 guest 系统当作磁盘使用 例如 libguestfs 这样的工具，能管理、备份及监控文件。 KVM 上的磁盘镜像格式包括： raw 当对磁盘 I/O 性能要求非常高，而且通常不需要通过网络传输镜像文件时，可以使用 raw 文件。不推荐使用 raw 镜像文件指不包含附加元数据的磁盘内容。 假如主机文件系统允许，raw 文件可以是预分配（pre-allocated）或稀疏（sparse）。稀疏文件根据需求分配主机磁盘空间（动态存储)，因此它是一种精简配置形式（thin provisioning）。预分配文件的所有空间需要被预先分配，但它比稀疏文件性能好。 qcow2 Red Hat Enterprise Linux 7.0 及更新版本支持 qcow2 v3 镜像文件格式。 动态存储，用多少就实际占用多少物理存储空间 qcow2 镜像文件提供许多高级磁盘镜像特征，如快照、压缩及加密。它们可以用来代表通过模板镜像创建的虚拟机。因为只有虚拟机写入的扇区部分才会分配在镜像中，所以 qcow2 文件的网络传输效率较高。 lvm卷(直接使用裸设备) LVM 精简配置为 LVM 卷提供快照和高效的空间使用，它可以作为 qcow2 的一种替代选择。 创建一个lvm卷给 guest 系统当作硬盘使用 逻辑卷可用于磁盘镜像，并使用系统的 LVM 工具进行管理。 由于它使用更简单的块储存模式，LVM 比文件系统的性能更高。 主机设备(直接使用裸设备) 在 SAN 而不是主机上进行储存管理时，可以使用主机设备 主机设备如物理 CD-ROM、原始磁盘或 LUN 都可以提供给客机。这使得 SAN 或 iSCSI LUN 还有本地 CD-ROM 都可以提供给客机所用。 分布式存储系统(直接使用裸设备) Gluster 卷可用作磁盘镜像。它提供了高效的、使用网络的集群存储。 Red Hat Enterprise Linux 7 包括在 GlusterFS 上对磁盘镜像的原生支援。这使 KVM 主机可以直接从 GlusterFS 卷引导虚拟机镜像，并使用 GlusterFS 卷中的镜像作为虚拟机的数据磁盘。与 GlusterFS FUSE 相比，KVM 原生支持性能更好。 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:3:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"4 KVM网络互联配置 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:4:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"5 优化KVM ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:5:0","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"5.1 CPU优化 要考虑CPU的数量问题，所有guest cpu的总数目不要超过物理机CPU总数目，如果超过，则将对性能带来严重影响，建议选择复制主机CPU配置。 “CPU 型号 ”（CPU model）规定了哪些主机 CPU 功能对客机操作系统有效。 qemu-kvm 和 libvirt 包含了几种当前处理器型号的定义，允许用户启用仅在新型 CPU 型号中可用的 CPU 功能。 对客机有效的的 CPU 功能取决于主机 CPU 的支持、内核以及 qemu-kvm 代码。 为了使虚拟机可以在具有不同 CPU 功能集的主机间安全地进行迁移，qemu-kvm 在默认状态下不会把主机 CPU 的所有功能都提供给客机操作系统，而是根据所选的 CPU 型号来为虚拟机提供相关的 CPU 功能。如果虚拟机启用了某个 CPU 功能，则此虚拟机无法迁移到不支持向客机提供此功能的主机上。 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:5:1","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"5.2 内存优化 主要分为主机优化和guest优化 KSM（kernel Samepage Merging）相同页合并 内存分配的最小单位是page（页面），默认大小是4KB，可以将host主机内容相同的内存合并，以节省内存的使用。 当KVM上运行许多相同系统的客户机时，客户机之间将有很多内存页是完全相同的，特别是只读的内核代码页完全可以在客户机之间共享，从而减少客户机占用的内存资源，也能同时运行更多的客户机。 使用KSM存在性能损失，在一般的环境中，性能损失大概是10%，这也是在某些环境中关闭KSM的原因。 建议开启KSM的同时不要使用memory balloon，两种内存优化方案会降低系统的性能; 在什么时候开启KSM？ 如果目标是运行尽可能多的虚拟机，而且性能不是问题，应该保持KSM处于运行状态。例如KSM允许运行30个虚拟机的主机上运行40个虚拟机，这意味着最大化硬件使用效率。 如果服务器在运行相对较少的虚拟机并且性能是个问题时，那么应该关闭KSM。 如果CPU是整个宿主机的资源瓶颈则不建议使用KSM，因为KSM会带来相应的CPU开销 KSM文件目录： $ ls /sys/kernel/mm/ksm/ 总用量 0 -r--r--r--. 1 root root 4096 11月 30 17:05 full_scans # 对可合并的内存区域扫描过的次数 -rw-r--r--. 1 root root 4096 11月 30 17:05 max_page_sharing -rw-r--r--. 1 root root 4096 11月 30 17:05 merge_across_nodes # 是否可以合并来自不同NUMA节点的页面。参数更改0,避免跨NUMA节点合并页面 -r--r--r--. 1 root root 4096 11月 30 17:05 pages_shared # 记录合并后共有多少内存页 -r--r--r--. 1 root root 4096 11月 30 17:05 pages_sharing # 记录有多少内存页正在使用被合并的共享页，不包括合并的内存页本身 -rw-r--r--. 1 root root 4096 11月 30 17:05 pages_to_scan # 决定每次扫描多少个页面默认是100，越大越好，超过2000无效，需要开启两个服务ksmtuned和tuned,支持更多页面 -r--r--r--. 1 root root 4096 11月 30 17:05 pages_unshared # 因为没有重复内容而不能被合并的内存页数量 -r--r--r--. 1 root root 4096 11月 30 17:05 pages_volatile # 因为内容很容易变化而不能被合并的内存页数量 -rw-r--r--. 1 root root 4096 11月 30 17:05 run # 查看是否开启KSM，0为关闭，1为开启,临时开启 echo 1 \u003e run 2为停止ksmd并分离已合并的内存页 -rw-r--r--. 1 root root 4096 11月 30 17:05 sleep_millisecs # 决定多长时间扫描一次 -r--r--r--. 1 root root 4096 11月 30 17:05 stable_node_chains -rw-r--r--. 1 root root 4096 11月 30 17:05 stable_node_chains_prune_millisecs -r--r--r--. 1 root root 4096 11月 30 17:05 stable_node_dups -rw-r--磁盘r--. 1 root root 4096 11月 30 17:05 use_zero_pages KSM管理 ksm可以直接配置/sys/kernel/mm/ksm/目录下的文件 ksmtuned管理 ksmtuned会一直保持循环执行，以调节ksm服务运行。 安装ksmtuned管理工具 yum install ksmtuned 编辑ksmtuned配置文件 # ksm每次内存扫描的时间; KSM_MONITOR_INTERVAL = 60 # 表示每次扫描休息的间隔时间(最小值为10)，KSM扫描会占用一些CPU的开销，所以当KVM虚拟机数量或者应用软件较少时可以调整KSM_SLEEP_MSEC至一个较大的值，反之则设置较小的值;同时当Hypervisor里面的虚拟机的内存调优到达一个稳定状态，也可以根据情况把这个参数调小节省CPU的开销; KSM_SLEEP_MSEC = 10 # 内存页合并增加数量; KSM_NPAGES_BOOST = 300 # 内存页合并减少数量; KSM_NPAGES_DECAY = -50 # 内存页合并最小值; KSM_NPAGES_MIN = 64 # 内存页合并最大值 KSM_NPAGES_MAX = 1250 # 临界值系数，越大合并的越多 KSM_THRES_COEF = 20 # 临界值常量 KSM_THRES_CONST = 2048 # 取消注释以下内容以启用ksmtuned调试信息 LOGFILE = /var/log/ksmtuned # DEBUG = 1 ksmtuned工作方法： ksm先取得到宿主机的总内存“total”， thres = total * KSM_THRES_COEF / 100。然后与临界值常量KSM_THRES_CONST进行比较，如果thres 小于 KSM_THRES_CONST，那么thres就 等于 KSM_THRES_CONST; 计算qemu进程使用的内存总和：committed; 当且仅当committed + thres \u003e total时，才开始操作内存页合并。所以调整临界值常量与临界值系数可以确定临界值thres, 从而有效地调整ksm工作方式。 判断剩余内存量free与thres的大小，如果free \u003c thres，ksm每次扫描后内存页合并数会增加 KSM_NPAGES_BOOST，该参数上限为KSM_NPAGES_MAX;反之如果free\u003ethres内存页合并数量会 减少 KSM_NPAGES_DECAY，下限为KSM_NPAGES_MIN。 对内存设置限制 如果我们有多个虚拟机，为了防止某个虚拟机无节制的使用内存资源，导致其他虚拟机无法正常使用，就需要对使用的内存进行限制。 不同的管理工具不同的配置方法，以virs为例 查看当前虚拟机的内存限制，单位为KB virsh memtune c7-1 hard_limit : 无限制 # 强制最大内存 soft_limit : 无限制 # 可用最大内存 swap_hard_limit: 无限制 # 强制最大swap使用大小 设置强制最大内存为100MB，在线生效。 virsh memtune c7-1 --hard-limit 1024000 --live virsh memtune c7-1 # 查看 hard_limit : 1024000 soft_limit : 无限制 swap_hard_limit: 无限制 大页后端内存 在逻辑地址想物理地址转换时，CPU保持一个翻译后备缓冲器TLB，用来缓冲转换结果，而TLB容量很小，所以如果page很小，TLB很容易就充满，这样就容易导致cache miss，相反page变大，TLB需要保存的缓存项就变少，就会减少cache miss，通过为客户端提供大页后端内存，就能减少客户机消耗的内存并提高TLB命中率，从而提高KVM性能。 在RHEL里，大页的大小可以是2M,1G.默认情况下，已经开启了透明大页功能 配置大页面后，系统在开机启动时会首选尝试在内存中找到并预留连续的大小为 HugePages_Total * Hugepagesize 的内存空间。如果内存空间不满足，则启动会报错 Kernel Panic, Out of Memory 等错误。 如只配置了一个大小的大页面，可以通过 /proc/meminfo 中的 Hugepagesize 和 HugePages_Total 计算出大页面所在内存空间的大小。这部分空间会被算到已用的内存空间里，即使还未真正被使用 查看内存信息，无可用大页 cat /proc/meminfo | grep Huge HugePages_Total: 0 # 大叶面的数量 HugePages_Free: 0 # 未使用的大叶面数量 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB # 每个大页面的大小 查看设置的大页面的数目 cat /proc/sys/vm/nr_hugepages 指定大页需要的内存页面数量,页面大小一般不更改， echo 25000 \u003e /proc/sys/vm/nr_hugepages # 临时生效 sysctl -w vm.nr_hugepages=25000 # 永久生效 或者 vim /etc/sysctl.conf vm.nr_hugepages=25000 sysctl -p # 重新加载配置 内存气泡 页面交换 qemu-kvm虚拟机作为系统的进程存在，所使用的内存可以利用系统的swap能力进行换出。不需要特别设置。 页面压缩 未见支持。 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:5:2","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"5.3 I/O等设备使用半虚拟化设备 采用virtio磁盘控制器 kvm设计了virtio类型的磁盘控制器，是针对磁盘和网络的一个半虚拟化接口，以提高效率为目的。 guest 系统需要安装半虚拟化驱动，Linux内核中已经集成进去了，window平台的话，必须手动安装 virtio-scsi 半虚拟化 SCSI 控制器设备是一种更为灵活且可扩展的 virtio-blk 替代品，irtio-scsi 客机能继承目标设备的各种特征，并且能操作几百个设备，相比之下，virtio-blk 仅能处理 28 台设备。使用大量磁盘或高级储功能（如 TRIM）的客机推荐使用的半虚拟化设备。 virtio-blk 适用于向客机提供镜像文件的半虚拟化储存设备。virtio-blk 可以为虚拟机提供最好的磁盘 I/O 性能，但比 virtio-scsi 的功能少。 其的半虚拟化设备 virtio-net 半虚拟化网络设备是虚拟化网络设备，它为虚拟机提供了网络访问能力，并可以提供网络性能及减少网络延迟。 半虚拟化时钟 使用时间戳计数器（TSC，Time Stamp Counter）作为时钟源的客机可能会出现与时间相关的问题。KVM 在主机外围工作，这些主机在向客机提供半虚拟化时间时没有固定的 TSC。此外，半虚拟化时钟会在客机运行 S3 或挂起 RAM 时帮助调整所需时间。半虚拟化时钟不支持 Windows guest。 virtio-serial 半虚拟化串口设备是面向比特流的字符流设备，它为主机用户空间与客机用户空间之间提供了一个简单的交流接口。 virtio-balloon 建议开启KSM的同时不要使用memory balloon，两种内存优化方案会降低系统的性能; 个人理解，动态使用内存，虚拟机使用多少就占用多少内存，但是也不可以超过限定值 气球（ballon）设备可以指定虚拟机的部分内存为没有被使用（这个过程被称为气球“充气 ” — inflation），从而使这部分内存可以被主机（或主机上的其它虚拟机）使用。当虚拟机需要这部分内存时，气球可以进行“放气 ”（deflated），主机就会把这部分内存重新分配给虚拟机。 virtio-rng 半虚拟化随机数字生成器使虚拟机可以直接从主机收集熵或随意值来使用，以进行数据加密和安全。因为典型的输入数据（如硬件使用情况）不可用，虚拟机常常急需熵。取得熵很耗时；virtio-rng 通过直接把熵从主机注入客机虚拟机从而使这个过程加快 。 QXL 半虚拟化图形卡与 QXL 驱动一同提供了一个有效地显示来自远程主机的虚拟机图形界面。SPICE 需要 QXL 驱动。 直接使用物理主机设备 特定硬件平台允许虚拟机直接访问多种硬件设备及组件。在虚拟化中，此操作被称为 “设备分配 ”（device assignment）。设备分配又被称作 “传递 ”（passthrough）。 需要物理设备支持 device assignment VFIO 设备分配 虚拟功能 I/O（VFIO）把主机系统上的 PCI 设备与虚拟机直接相连，允许客机在执行特定任务时有独自访问 PCI 设备的权限。这就象 PCI 设备物理地连接到客机虚拟机上一样。通过把设备分配从 KVM 虚拟机监控系统中(半虚拟化和全虚拟化)移出，并在内核级中强制进行不同guest之间进行设备隔离，VFIO 安全性更高且与安全启动兼容。在 Red Hat Enterprise Linux 7 中，它是默认的设备分配机制。VFIO 可以分配的设备数量为32个， 并且支持对 NVIDIA GPU 的分配。 USB传递 USB 设备分配允许客机拥有在执行特定任务时有专有访问 USB 设备的权利。这就象 USB 设备物理地连接到虚拟机上一样。 SR-IOV 简单的说，SR-IOV是一种虚拟化方案，用来使一个PCIe的物理设备，能虚拟出多个设备，这些虚拟出来的设备看起来就像是多个真实的物理设备一样，并获得能够与本机性能媲美的 I/O 性能。 SR-IOV现在最多是用在网卡上，kvm虚拟机的网卡功能一般会下降到实体机的30-50%，如果改用SR-IOV会大大提高网卡性能。 SR-IOV 有2种功能： 物理功能 (Physical Function, PF): 就是标准的PCIe的功能了 虚拟功能 (Virtual Function, VF): 与物理功能关联的一种功能。VF 是一种轻量级 PCIe 功能，可以与物理功能以及与同一物理功能关联的其他 VF 共享一个或多个物理资源。VF 仅允许拥有用于其自身行为的配置资源。 NPIV NPIV 可以提供带有企业级存储解决方案的高密度虚拟环境。 N_Port ID Virtualization（NPIV）是对光纤通道设备有效的功能。NPIV 共享单一物理 N_Port 作为多个 N_Port ID。NPIV 为 HBA（光纤通道主机总线适配器，Fibre Channel Host Bus Adapter）提供和 SR-IOV 为 PCIe 接口提供的功能相似的功能。有了 NPIV，可以为 SAN（存储区域网络，Storage Area Network）提供带有虚拟光纤通道发起程序的虚拟机。 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/:5:3","tags":["libvirt"],"title":"KVM libvirt学习笔记","uri":"/posts/virtual-machines/libvirt/02-libvirtd-introduction/"},{"categories":["Virtual Machines"],"content":"介绍使用libvirt来管理Linux的KVM虚拟机","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/","tags":["libvirt"],"title":"libvirt和qemu-kvm安装","uri":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/"},{"categories":["Virtual Machines"],"content":"记录在linux系统上安装libvirt和qemu-kvm的过程 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/:0:0","tags":["libvirt"],"title":"libvirt和qemu-kvm安装","uri":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/"},{"categories":["Virtual Machines"],"content":"1 查看是否支持kvm虚拟化 CPU必需支持虚拟化，可以在/proc/cpuinfo文件中想找flags，如果是inter的显示为vmx，amd的显示为svm cat /proc/cpuinfo | egrep \"(vmx|svm)\" CPU必需支持64位操作系统，可以在上述文件中查找lm标记，如果有则支持 cat /proc/cpuinfo | egrep lm 系统必需为64为的RHEL，且系统版本为RHEL6.4及以上为最佳uname -a 必需在BIOS里开启CPU的VT功能 lsmod | grep kvm ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/:1:0","tags":["libvirt"],"title":"libvirt和qemu-kvm安装","uri":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/"},{"categories":["Virtual Machines"],"content":"2 编译安装qemu和libvirt（未完成） 下载文件 # 可以去官网下载最新的 wget https://download.qemu.org/qemu-6.2.0.tar.xz tar -xf qemu-6.2.0.tar.xz cd qemu-6.2.0/ 安装需要用到的库文件 yum install git glib2-devel libfdt-devel pixman-devel zlib-devel bzip2-devel libaio-devel spice-server-devel spice-protocol libusb-devel usbredir-devel 编译安装 ./configure \\ # 编译完成后安装的目录 --prefix=/opt/qemu-kvm \\ # 指定数据目录 --datadir=/home/data/kvm \\ --target-list=i386-softmmu,x86_64-softmmu \\ --enable-system \\ --disable-debug-info \\ --enable-usb-redir \\ --enable-libusb \\ --enable-spice \\ --enable-uuid \\ # 开启KVM支持 --enable-kvm \\ --enable-bzip2 \\ --enable-linux-aio \\ --enable-tools # 编译，并安装到/opt/qemu-kvm目录下 make -j4 \u0026\u0026 make install 创建环境变量和添加sytemd服务 ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/:2:0","tags":["libvirt"],"title":"libvirt和qemu-kvm安装","uri":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/"},{"categories":["Virtual Machines"],"content":"3 YUM安装 centos默认存储库的版本过低，添加virt存储库，然后通过yum安装 添加qemu扩展存储库 yum install centos-release-qemu-ev 安装qemu和libvirt yum install qemu-kvm libvirt -y ","date":"2020-08-30","objectID":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/:3:0","tags":["libvirt"],"title":"libvirt和qemu-kvm安装","uri":"/posts/virtual-machines/libvirt/01-install-libvirt-kvm/"},{"categories":["Virtual Machines"],"content":"使用编译的方式在linux服务器上安装git","date":"2020-08-30","objectID":"/posts/virtual-machines/gns3/","tags":["GNS3"],"title":"linux安装GNS3的VPCS、dynamips、IOU支持","uri":"/posts/virtual-machines/gns3/"},{"categories":["Virtual Machines"],"content":"linux安装GNS3的VPCS、dynamips、IOU支持，目前是使用fedora29来安装的，可能也支持fedora30，但是fedora31未经过测试，不晓得支持不 gns3 安装使用 ","date":"2020-08-30","objectID":"/posts/virtual-machines/gns3/:0:0","tags":["GNS3"],"title":"linux安装GNS3的VPCS、dynamips、IOU支持","uri":"/posts/virtual-machines/gns3/"},{"categories":["Virtual Machines"],"content":"1 gns3 vpcs and dynamips 安装 dnf copr enable athmane/gns3-extra dnf install vpcs dynamips ","date":"2020-08-30","objectID":"/posts/virtual-machines/gns3/:1:0","tags":["GNS3"],"title":"linux安装GNS3的VPCS、dynamips、IOU支持","uri":"/posts/virtual-machines/gns3/"},{"categories":["Virtual Machines"],"content":"2 gns3 IOU for linux 安装 fedora 29 sudo dnf install git bison flex gcc make openssl-libs.i686 libgcc.i686 git clone http://github.com/ndevilla/iniparser.git cd iniparser make sudo cp libiniparser.* /usr/lib/ sudo cp src/iniparser.h /usr/local/include sudo cp src/dictionary.h /usr/local/include cd .. git clone https://github.com/GNS3/iouyap.git cd iouyap make sudo make install ","date":"2020-08-30","objectID":"/posts/virtual-machines/gns3/:2:0","tags":["GNS3"],"title":"linux安装GNS3的VPCS、dynamips、IOU支持","uri":"/posts/virtual-machines/gns3/"},{"categories":["linux software"],"content":"linux系统基准测试工具sysbenchtest的安装和使用","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"linux系统基准测试工具sysbenchtest的安装和使用 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:0:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"1 Sysbench安装 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:1:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"1.1 二进制安装 centos yum install epel-release # 安装centos社区源 yum install sysbench # 安装sysbench ubuntu curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.deb.sh | sudo bash # sudo apt -y install sysbench ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:1:1","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"1.2 编译安装 github编译安装介绍：https://github.com/akopytov/sysbench#building-and-installing-from-source 下载源代码 github地址：https://github.com/akopytov/sysbench/releases wget https://github.com/akopytov/sysbench/archive/1.0.16.tar.gz tar -zxvf 1.0.16.tar.gz 安装依赖 centos yum -y install make automake libtool pkgconfig libaio-devel # For MySQL support, replace with mysql-devel on RHEL/CentOS 5 yum -y install mariadb-devel openssl-devel # For PostgreSQL support yum -y install postgresql-devel ubuntu apt -y install make automake libtool pkg-config libaio-dev # For MySQL support apt -y install libmysqlclient-dev libssl-dev # For PostgreSQL support apt -y install libpq-dev 编译安装 ./autogen.sh # Add --with-pgsql to build with PostgreSQL support ./configure make -j make install ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:1:2","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"2 参数解析 一般语法 sysbench的常规命令行语法是： sysbench [options] ... [testname] [command] testname 是内置测试的可选名称(例如fileio，memory，cpu,threads,mutex等)，或捆绑的Lua脚本之一的名称（例如oltp_read_only, 或自定义Lua脚本的path。 如果不测试名称在命令行中指定（因此，没有command也是如此，因为它将被解析为testname），或测试名称是破折号(\" - “)，然后sysbench期望Lua脚本执行其标准输入。 command 是一个可选参数，将由sysbench传递给用testname指定的内置测试或脚本。 command定义必须由测试执行的action。清单可用命令取决于特定测试。一些测试也实现自己的自定义命令。 以下是典型测试命令及其用途的说明： prepare：为需要的测试执行准备操作它们，例如在磁盘上为fileio创建必要的文件测试或填充测试数据库以获取数据库基准。 run：运行用testname指定的实际测试论点。所有测试都提供此命令。 cleanup：在测试运行后删除临时数据创建一个的测试。 help：显示使用指定的测试的使用信息 testname: 参数。这包括完整的命令列表由测试提供，因此它应该用于获得可用命令。 options 是0个或多个命令行选项的列表。与command一样，sysbench testname help命令应该用来描述a提供的可用选项特别测试。 请参见常规命令行选项有关sysbench本身提供的常规选项的说明。 您可以使用sysbench --help来显示常规命令行语法和选项。 常规命令行选项 选项 说明 默认值 --threads 要创建的工作线程总数 1 --events 请求总数限制(一个循环即一个event,这个定义执行多少个event)。0（默认值）表示没有限制 0 --time 限制总执行时间（以秒为单位）。0表示没有限制 10 --warmup-time 执行多少秒的events后再启用实际基准测试统计信息，n秒之前禁用实际基准测试统计信息, 0 --rate 该数字指定平均每个线程应执行的每秒event数。0（默认值）表示无限速率，即事件尽可能快地执行 0 --thread-init-timeout 工作线程初始化的等待时间（以秒为单位） 30 --thread-stack-size 每个线程的堆栈大小 32K --report-interval 定期报告具有指定间隔（以秒为单位）的中间统计信息 请注意，此选项生成的统计信息是按时间间隔而不是累积。0禁用中间报告 0 --debug 打印更多调试信息 关 --validate 尽可能执行测试结果的验证 关 --help 打印有关一般语法或指定测试的帮助，然后退出 关 --verbosity 详细级别（0 - 仅关键消息，5 - 调试） 4 --percentile 此选项允许指定要计数的查询执行时间的百分位数等级， （例如，95％百分位意味着我们应该减少5％的最长请求并从剩余的请求中选择最大值） 95 --luajit-cmd 执行LuaJIT控制命令。这个选项相当于luajit -j。有关更多信息，请参阅[LuaJIT文档]http://luajit.org/running.html#opt_j 请注意，可以通过附加相应的乘法后缀（K表示千字节，M表示兆字节，G表示千兆字节，T表示太字节）来指定所有大小选项（–thread-stack-size如此表中）的数值。 随机数选项 选项 说明 默认值 --rand-type 随机数字分布{uniform，gaussian，special，pareto，zipfian}默认使用。基准脚本可以选择使用默认分发，或者明确指定它，即覆盖默认分配。 特别 --rand-seed 随机数发生器的种子。当为0时，当前时间用作RNG种子。 0 --rand-spec-iter 特殊分布的迭代次数 12 --rand-spec-pct 特殊分布中“特殊”值落入的整个范围的百分比 1 --rand-spec-res 用于特殊分发的’特殊’值的百分比 75 --rand-pareto-h 帕累托分布的形状参数 0.2 --rand-zipfian-exp Zipfian分布的形状参数（theta） 0.8 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:2:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"3 CPU测试 sysbench的cpu测试是在指定时间内，循环进行素数计算 素数（也叫质数）就是从1开始的自然数中，无法被整除的数，比如2、3、5、7、11、13、17等。编程公式：对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为素数。 循环计算cpu-max-prime定义的素数为一个event # 素数上限2万，默认10秒，1个线程 sysbench cpu --cpu-max-prime=20000 --threads=1 run --cpu-max-prime 素数生成数量的上限, ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:3:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"4 内存测试 测试内存的联系读写性能 读或者写一个memory-block-size大小，即一个event # 使用8k的内存块测试1G的数据 sysbench memory --memory-block-size=8k --memory-total-size=10G run memory-block-size 测试时内存块大小。默认是1K memory-total-size 传输数据的总大小。默认是100G memory-scope 内存访问范围{global,local}。默认是global memory-hugetlb[=on|off] 从HugeTLB池内存分配。默认是off memory-oper 内存操作类型。{read, write, none} 默认是write memory-access-mode 存储器存取方式{seq,rnd} 默认是seq ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:4:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"5 文件I/O测试 磁盘IO性能测试[主要看每秒请求数(request)和总体的吞吐量(total) 一次IO请求为一个event # 准备测试文件 sysbench fileio --threads=2 --file-total-size=2G prepare # 测试 sysbench fileio --threads=2 --file-total-size=2G --file-test-mode=rndrw --time=10 run # 删除测试数据 sysbench fileio --threads=2 --file-total-size=2G cleanup file-num=N 创建测试文件的数量。默认是128 file-block-size=N 测试时文件块的大小。默认是16384(16K) file-total-size=SIZE 测试文件的总大小。默认是2G file-test-mode=STRING 文件测试模式{seqwr(顺序写), seqrewr(顺序读写), seqrd(顺序读), rndrd(随机读), rndwr(随机写), rndrw(随机读写)} file-io-mode=STRING 文件操作模式{sync(同步),async(异步),fastmmap(快速map映射),slowmmap(慢map映射)}。默认是sync file-async-backlog=N 每个线程排队的异步操作数默认是128 file-extra-flags=[LIST,…] 使用额外的标志来打开文件{sync(同步),async(异步),direct} 。默认为空 file-fsync-freq=N 在这个请求数之后执行fsync()。(0 – 不使用fsync())。默认是100 file-fsync-all[=on|off] 每执行完一次写操作就执行一次fsync。默认是off file-fsync-end[=on|off] 在测试结束时才执行fsync。默认是on file-fsync-mode=STRING 使用哪种方法进行同步{fsync, fdatasync}。默认是fsync file-merged-requests=N 如果可以，合并最多的I/O请求数(0 – 表示不合并)。默认是0 file-rw-ratio=N 测试时的读写比例。默认是1.5 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:5:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"6 线程基准测试 thread-locks小于线程数除以2，lock越少，处理时间越长 sysbench threads --threads=2 --thread-yields=2000 --thread-locks=10 run thread-yields=N 每个请求产生多少个线程。默认是1000 thread-locks=N 每个线程的锁的数量。默认是8 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:6:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"7 互斥锁基准测试 使用互斥锁工作负载时，sysbench应用程序将为每个线程运行单个请求。此请求将首先对CPU施加压力（使用简单的增量循环，通过--mutex-loops参数），之后它将采用随机互斥（锁定），递增全局变量并再次释放锁定。通过lock（--mutex-locks）的数量重复该过程若干次。随机互斥锁取自--mutex-num参数大小的池。 此处运行的持续时间很重要，但必须考虑到线程将从可用池中获取随机互斥锁。这个随机因素可能会对结果产生一些影响。 sysbench mutex --threads=100 --mutex-num=1000 --mutex-locks=100000 --mutex-loops=10000 run mutex-num=N 数组互斥的总大小。默认是4096 mutex-locks=N 每个线程互斥锁的数量。默认是50000 mutex-loops=N 内部互斥锁的空循环数量。默认是10000 ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:7:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"8 sql测试（等用到的时候在做笔记） ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:8:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"9 结果解析 General statistics: total time: 10.0024s total number of events: 3467 Latency (ms): min: 2.84 avg: 2.88 max: 8.98 95th percentile: 2.91 sum: 10000.21 Threads fairness: events (avg/stddev): 3467.0000/0.00 execution time (avg/stddev): 10.0002/0.00 Latency 一般统计,单位:ms total time 执行测试花费的总时间 total number of events 测试总共执行了多少个event Latency (ms) 单个请求统计 min 执行单个event的最小时间，单位：ms avg 执行所有event的平均时间，单位：ms max 执行单个event的最大时间，单位：ms 95th percentile 95%次event完成的时间 sum 执行的总共时间 Threads fairness events (avg/stddev) 平均每个线程完成3255次event。stddev为线程之间的标准差，对于单线程无意义 execution time (avg/stddev) 每个线程平均耗时多少秒。stddev为线程之间的标准差，对于单线程无意义 对比规则： 相同时间，比较的是谁完成的event多 相同event，比较的是谁用时更少 时间和event都相同，比较stddev(标准差) ","date":"2020-08-30","objectID":"/posts/linux-software/sysbenchtest/:9:0","tags":["SysbenchTest"],"title":"linux系统基准测试工具sysbenchtest的安装和使用","uri":"/posts/linux-software/sysbenchtest/"},{"categories":["linux software"],"content":"linux安装最新版的mysql记录，通过存储库、二进制、编译三种方式进行安装mysql","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"linux安装最新版的mysql记录，通过存储库、二进制、编译三种方式进行安装mysql ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:0:0","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1 通过yum软件库安装Mysql 以下命令对于启用了dnf的系统，用dnf替换命令中的 yum 发布软件包安装在系统上，yum update 命令（或dnf-enabled系统的dnf升级）进行的任何系统范围的更新都会自动升级系统上的MySQL软件包，并且还会替换任何本地的第三方软件包在MySQL Yum存储库中找到替代者 默认配置文件路径： 配置文件：/etc/my.cnf 日志文件：/var/log# var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:0","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1.1 安装MySQL RPM Yum存储库添加到系统的存储库列表中 到MySQL存储库下载适用linux版本的发行包，点我下载 使用以下命令安装下载的发行包 rpm -Uvh 发行包名称 ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:1","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1.2 选择一个mysql安装版本 当使用MySQL Yum存储库时，默认选择安装MySQL的最新GA版本进行安装。如果这是你想要的，你可以跳到下一步， 用Yum安装MySQL 查看MySQL Yum存储库中的所有子存储库，并查看其中哪些被启用或禁用 yum repolist all | grep mysql # 查看MySQL Yum存储库中的所有子存储库，并查看其中哪些被启用或禁用 sudo yum-config-manager --disable mysql**-community # 禁用最新的GA系列的子库 sudo yum-config-manager --enable mysql**-community # 启用特定GA系列的子库 如若不支持yum-config-manager命令，可以通过修改etc/yum.repos.d/mysql-community.repo来解决， vim etc/yum.repos.d/mysql-community.repo # 打开文件,找到要配置的子库的条目，然后编辑该enabled选项,指定 enabled=0禁用子库，或 enabled=1启用子库 yum repolist enabled | grep mysql # 验证是否已启用和禁用了正确的子库 为一个发行版系列启用子库。当启用多个版本系列的子库时，Yum将使用最新的系列 ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:2","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1.3 安装mysql yum install mysql-community-server # 安装MySQL，装MySQL服务器的软件包以及其他必需的软件包 ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:3","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1.4 启动MySQL服务器 service mysqld start # 启动MySQL服务 systemctl start mysqld.service # EL7的启动命令，首选 service mysqld status # 查看MySQL服务的状态 ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:4","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"1.5开机启动mysql systemctl enable mysqld systemctl daemon-reload ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:1:5","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"2 MySQL服务器初始化（仅适用于MySQL 5.7) mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码（初始化）。通过下面的方式找到root默认密码，然后登录mysql进行修改 grep 'temporary password' /var/log/mysqld.log # 显示初始的超级用户的密码 mysql_secure_installation # 初始mysql，后边可以不用操作 mysql -uroot -p # 使用初始密码登陆 mysql\u003e ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!'; mysql\u003e set password for 'root'@'localhost'=password('MyNewPass4!'); # 更改密码，两条命令选择一条即可 mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 show variables like '%password%'; # 通过msyql环境变量可以查看密码策略的相关信息 \u003e validate_password_policy: # 密码策略，默认为MEDIUM策略 validate_password_dictionary_file： # 密码策略文件，策略为STRONG才需要 validate_password_length： # 密码最少长度 validate_password_mixed_case_count： # 大小写字符长度，至少1个 validate_password_number_count: # 数字至少1个 validate_password_special_char_count： # 特殊字符至少1个 共有以下几种密码策略： 策略 检查规则 0 or LOW Length 1 or MEDIUM Length; numeric, lowercase/uppercase, and special characters or STRONG Length; numeric, lowercase/uppercase, and special characters; dictionary file MySQL官网密码策略详细说明：点击查看 修改密码策略 vim /etc/my.cnf # 打开mysql的配置文件 validate_password_policy=0 # 添加一种密码策略，选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件 validate_password = off # 如果不需要密码策略，添加my.cnf文件中添加这一行的配置禁用即可 systemctl restart mysqld # 重新启动mysql服务使配置生效： ","date":"2020-08-30","objectID":"/posts/linux-software/mysql/01-install-mysql/:2:0","tags":["mysql"],"title":"MySQL数据库安装与配置","uri":"/posts/linux-software/mysql/01-install-mysql/"},{"categories":["linux software"],"content":"openssh配置指南，linux免密登录配置方法等等","date":"2020-08-30","objectID":"/posts/linux-software/01-openssh/","tags":["linux"],"title":"openssh配置指南","uri":"/posts/linux-software/01-openssh/"},{"categories":["linux software"],"content":"openssh配置指南，linux免密登录配置方法等等 openssh学习笔记 ","date":"2020-08-30","objectID":"/posts/linux-software/01-openssh/:0:0","tags":["linux"],"title":"openssh配置指南","uri":"/posts/linux-software/01-openssh/"},{"categories":["linux software"],"content":"1 CentOS 7 OpenSSH 配置 默认自动安装SSH并开启密码登陆 开启密钥登陆 ssh localhost # 首次登陆下,生成~/.ssh目录 exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat id_rsa.pub \u003e\u003e authorized_keys # 加入授权 chmod 600 ./authorized_keys# 修改文件权限 vim /etc/ssh/sshd_config # 修改sshd_config，并把PubkeyAuthentication yes前边的#去除 下载id_rsa id_rsa.pub两个密钥 # CRT下载方式为 Alt+P建进入SFTP,get命令下载，help命令帮助，要SSH登陆 sshd_config配置 service sshd restart# 修改配置文件后重启SSHDf服务 UseDNS=no # DNS反向解析，根据用户的IP使用反向DNS找到主机名，再使用DNS找到IP最后匹配一下登录的IP是否合法。 —————以上设置影响SSH登陆速度————— ","date":"2020-08-30","objectID":"/posts/linux-software/01-openssh/:1:0","tags":["linux"],"title":"openssh配置指南","uri":"/posts/linux-software/01-openssh/"},{"categories":["network"],"content":"编译安装openvpn，并配置lan to lan","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"openvpn的安装配置记录 openvpn安装配置记录 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:0:0","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"1 编译安装openvpn ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:1:0","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"1.1 编译安装 安装编译依赖库 yum -y install gcc gcc-c++ make autoconf openssl-devel lzo-devel pam-devel systemd-devel systemd-libs 下载并配置编译环境 cd /usr/local/src/ # 需要翻墙，我是翻墙下载过来上传上去的 wget https://swupdate.openvpn.org/community/releases/openvpn-2.4.6.tar.gz # 解压并进入目录 tar -zxf openvpn-2.4.6.tar.gz cd openvpn-2.4.6 # 配置编译选项，--prefix控制安装目录 ./configure \\ --prefix=/opt/openvpn \\ --enable-selinux \\ --enable-systemd \\ --enable-server \\ --enable-plugins \\ --enable-management \\ --enable-multihome \\ --enable-port-share \\ --disable-debug \\ --enable-iproute2 \\ --enable-plugin-auth-pam \\ --enable-pam-dlopen \\ --enable-async-push 安装openvpn到/opt/openvpn目录中 make -j4 \u0026\u0026 make install ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:1:1","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"1.2 添加环境变量和服务 配置环境变量 vim /etc/profile # 编辑profile export PATH=$PATH:/opt/openvpn/sbin/ # 在最后一行添加，然后就可以直接使用 openvpn命令了 添加man手册 这步可有可无，无伤大雅 vim /etc/man_db.conf # 编辑man配置文件 # 在MANDATORY_MANPATH文件位置添加以下字符串 MANDATORY_MANPATH /opt/openvpn/share/man 加载内核模块 lsmod | grep tun # 查看模块是否有tunnel4和tun模块 # 安装缺少的模块 modprobe tunnel4 modprobe tun 添加到系统服务并创建配置文件 cd /opt/openvpn # 进入openvpn的安装目录目录 cp ./lib/systemd/system/openvpn-server@.service /usr/lib/systemd/system/openvpn@server.service # 拷贝服务文件到系统服务目录 mkdir -p /etc/openvpn/server/ # 创建配置文件目录 cd /usr/local/src/openvpn-2.4.6/ # 进入源文件目录 cp sample/sample-config-files/server.conf /etc/openvpn/server/server.conf # 拷贝配置文件 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:1:2","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2 生成服务端和客户端证书 可以创建无数个client的key,每个客户端key的名字不可以一样，创建的文件介绍参照以下表格,迪菲·赫尔曼交换密钥根据KEY-SIZE定义的 key名字 用途介绍 安全程度 ca.crt ca证书 低，客户端和服务端都需要 ca.key ca秘钥 最高，只有服务端需要 dh.pem 迪菲·赫尔曼交换密钥 中，只有服务端需要 server.crt 服务端证书 高，只有服务端需要 server.key 服务端秘钥 高，只有服务端需要 ta.key（可选） TLS-auth密钥 高，客户端和服务端都需要 client1.crt 客户端证书 中，只有客户端需要 client1.key 客户端秘钥 高，只有客户端需要 ……… N多客户端证书和秘钥 中，只有客户端需要 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:0","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2.1 下载和配置easyrsa 下载easyrsa cd /usr/local/src/ git clone https://github.com/OpenVPN/easy-rsa.git cp -R easy-rsa /opt/openvpn/ cd /opt/openvpn/easy-rsa cp vars.example vars 配置vars文件 vim vars # 修改一下位置的对应值 set_var EASYRSA_REQ_COUNTRY \"CN\" # 所在国家 set_var EASYRSA_REQ_PROVINCE \"Shanghai\" # 所在省 set_var EASYRSA_REQ_CITY \"Shanghai\" # 所在市 set_var EASYRSA_REQ_ORG \"zhangcc\" # 版权信息 set_var EASYRSA_REQ_EMAIL \"admin@126.com\" # 邮箱地址 set_var EASYRSA_REQ_OU \"my openvpn\" # 组织或公司名称 # 可选配置项目 set_var EASYRSA_PKI \"$PWD/pki\" # 生成的key存放目录，默认当前目录的pki文件夹下 set_var EASYRSA_OPENSSL \"openssl\" # openssl程序的目录，如果没有创建openssl的环境变量，需要指定绝对路径 set_var EASYRSA_KEY_SIZE 2048 # 秘钥加密位数，最高4096,只有加密方式为rsa时生效，默认2048 set_var EASYRSA_ALGO rsa # 加密方式,默认rsa，支持rsa和ecc set_var EASYRSA_CA_EXPIRE 3650 # 根ca的有效期（单位：天） set_var EASYRSA_CERT_EXPIRE 3650 # 证书的有效期（单位：天） set_var EASYRSA_SSL_CONF \"$EASYRSA/openssl-easyrsa.cnf\" # openssl的配置文件目录 初始化 ./easyrsa init-pki # 初始化 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:1","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2.2 根ca证书 生成CA证书和秘钥，秘钥文件在./key/private/下 ./easyrsa build-ca # 执行生成CA命令 # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars Generating a 2048 bit RSA private key ...............................................................+++ .............................................................................................................+++ writing new private key to '/opt/openvpn/easy-rsa/key/private/ca.key.kxuwxGnM5I' Enter PEM pass phrase: # 输入密码，用来证书签名 Verifying - Enter PEM pass phrase: # 确认密码 ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Common Name (eg: your user, host, or server name) [Easy-RSA CA]:myname # 输入一个common name CA creation complete and you may now import and sign cert requests. Your new CA certificate file for publishing is at: /opt/openvpn/easy-rsa/key/ca.crt ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:2","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2.3 服务端证书 生成服务端证书和秘钥，证书和秘钥文件分别在./key/reqs/和./key/private/下 ./easyrsa gen-req server nopass # 生成命令，server为服务端秘钥名称，nopass为不加密秘钥 # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars Generating a 2048 bit RSA private key ...........+++ ..............+++ writing new private key to '/opt/openvpn/easy-rsa/key/private/server.key.eF1Ve9ejPO' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Common Name (eg: your user, host, or server name) [server]:MyServerKey # 输入一个common name,不要同于CA的common name Keypair and certificate request completed. Your files are: req: /opt/openvpn/easy-rsa/key/reqs/server.req key: /opt/openvpn/easy-rsa/key/private/server.key 签约服务器端证书 ./easyrsa sign server server # 签约server证书为server # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a server certificate for 3650 days: subject= commonName = MyServerKey Type the word 'yes' to continue, or any other input to abort. Confirm request details: yes # 输入yes Using configuration from ./openssl-easyrsa.cnf Enter pass phrase for /opt/openvpn/easy-rsa/key/private/ca.key: # 输入CA的数字签名密码 Check that the request matches the signature Signature ok The Subject's Distinguished Name is as follows commonName :ASN.1 12:'MyServerKey' Certificate is to be certified until Sep 11 17:11:55 2028 GMT (3650 days) Write out database with 1 new entries Data Base Updated Certificate created at: /opt/openvpn/easy-rsa/key/issued/server.crt 创建Diffie-Hellman，确保key穿越不安全网络 ./easyrsa gen-dh # 生成Diffie-Hellman # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars Generating DH parameters, 2048 bit long safe prime, generator 2 This is going to take a long time ............................................................... ............................................................... +.............................................................. ............................................................... +..........+.........................++*++* DH parameters of size 2048 created at /opt/openvpn/easy-rsa/key/dh.pem ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:3","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2.4 客户端证书 生成客户端证书和秘钥，证书和秘钥文件分别在./key/reqs/和./key/private/下 ./easyrsa gen-req mysql nopass # mysql为客户端key的名称，nopass为不加密秘钥 # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars Generating a 2048 bit RSA private key ..........................................................................+++ .................................................................+++ writing new private key to '/opt/openvpn/easy-rsa/key/private/mysql.key.q5Kb4bC4el' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Common Name (eg: your user, host, or server name) [mysql]:mysql-to-core # # 输入一个common name,不要同于CA的common name Keypair and certificate request completed. Your files are: req: /opt/openvpn/easy-rsa/key/reqs/mysql.req key: /opt/openvpn/easy-rsa/key/private/mysql.key 签约客户端秘钥 ./easyrsa sign client mysql # 签约客户端mysql秘钥 # 以下为命令回显 Note: using Easy-RSA configuration from: ./vars You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a client certificate for 3650 days: subject= commonName = mysql-to-core Type the word 'yes' to continue, or any other input to abort. Confirm request details: yes # 输入yes同意 Using configuration from ./openssl-easyrsa.cnf Enter pass phrase for /opt/openvpn/easy-rsa/key/private/ca.key: # 输入CA的数字签名密码 Check that the request matches the signature Signature ok The Subject's Distinguished Name is as follows commonName :ASN.1 12:'mysql-to-core' Certificate is to be certified until Sep 11 17:42:07 2028 GMT (3650 days) Write out database with 1 new entries Data Base Updated Certificate created at: /opt/openvpn/easy-rsa/key/issued/mysql.crt 生成TLS-auth秘钥（可选） 这一步骤是可选操作。OpenVPN提供了TLS-auth功能，可以用来抵御Dos、UDP端口淹没攻击。出于安全考虑，你可以启用该功能；生成key命令如下： openvpn --genkey --secret /opt/openvpn/easy-rsa/key/ta.key ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:4","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"2.5 查看和撤销一个证书 查看证书的签约 ./easyrsa show-cert mykey full # mykey代表自己的以.crt为后缀签约过的证书名字 ./easyrsa show-cert mykey full # mykey代表自己的以.req为后缀的证书名字 撤销证书的签约 ./easyrsa revoke mykey # mykey代表自己的以.crt为后缀证书名字 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:2:5","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"3 配置openvpn 拷贝key文件到配置目录 mkdir ~/openvpn-client # 创建存放客户端秘钥的文件架 # copy客户端key和配置到～/openvpn-client，配置文件在安装包里边的 cp /opt/openvpn/easy-rsa/key/private/mysql.key ~/openvpn-client/ cp /opt/openvpn/easy-rsa/key/issued/mysql.crt ~/openvpn-client/ cp /opt/openvpn/easy-rsa/key/ca.crt ~/openvpn-client/ cp /opt/openvpn/easy-rsa/key/ta.key ~/openvpn-client/ cp /usr/local/src/openvpn-2.4.6/sample/sample-config-files/client.conf ~/openvpn-client/ # copy服务端key到/etc/openvpn/server cp /opt/openvpn/easy-rsa/key/private/server.key /etc/openvpn/server/ cp /opt/openvpn/easy-rsa/key/issued/server.crt /etc/openvpn/server/ cp /opt/openvpn/easy-rsa/key/private/ca.key /etc/openvpn/server/ cp /opt/openvpn/easy-rsa/key/ca.crt /etc/openvpn/server/ cp /opt/openvpn/easy-rsa/key/ta.key /etc/openvpn/server/ cp /opt/openvpn/easy-rsa/key/dh.pem /etc/openvpn/server/ ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:3:0","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"3.1 服务端配置 打开服务端配置文件，并按照需要修改，把 “；”去掉即可启用 vim /etc/openvpn/server/server.conf # 定义openvpn监听的IP地址，单网卡的可以不注明，但是多网卡的建议注明。 ;local a.b.c.d # 定义openvpn监听的的端口，默认为1194端口。 port 1194 # 定义openvpn使用的协议，默认使用UDP。如果是生产环境的话，建议使用TCP协议。（二选一） ;proto tcp proto udp # 定义openvpn运行时使用哪一种模式，有两种运行模式一种是tap模式，一种是tun模式。（二选一） # tap模式也就是桥接模式，通过软件在系统中模拟出一个tap设备，该设备是一个二层设备，同时支持链路层协议 # tun模式也就是路由模式，通过软件在系统中模拟出一个tun路由，tun是ip层的点对点协议。 # 具体使用哪一种模式，需要根据自己的业务进行定义。 ;dev tap dev tun # windwos系统如果有多个TAP-Win32 适配器，这里需要指定名称，也需要禁用TAP适配器的防火墙，其他系统不用操作 ;dev-node MyTap # 定义openvpn使用的CA证书文件，该文件通过./easyrsa build-ca命令生成，CA证书主要用于验证客户证书的合法性。 ca ca.crt # 定义openvpn服务器端使用的证书和key文件位置。 cert server.crt key server.key # 这个文件应该保密 # 定义Diffie hellman文件位置 dh dh.pem # 分配一个30位掩码的ip地址，除非需要支持很久的系统，不然不推荐开启 ;topology subnet # 定义openvpn在使用tun路由模式时，分配给client端分配的IP地址段。 server 192.168.250.0 255.255.255.0 # 定义openvpn客户端和虚拟ip地址之间的关系。特别是在openvpn重启时,再次连接的客户端将依然被分配和断开之前的IP地址。 ifconfig-pool-persist ipp.txt # 定义openvpn在使用tap桥接模式时，分配给客户端的IP地址段。 ;server-bridge 192.168.250.0 255.255.255.0 10.8.0.50 192.168.250.1 # 定义openvpn在使用tap桥接模式时，客户端从dhcp服务器获取ip地址，客户端配置，服务端无需配置 ;server-bridge # 向所有客户端推送的路由信息 ;push \"route 192.168.10.0 255.255.255.0\" ;push \"route 192.168.20.0 255.255.255.0\" # 在/etc/openvpn/server/ccd目录下（如果没有手动创建）创建以客户端命名（证书的CN信息）的文件,来修改客户端的参数 client-config-dir /etc/openvpn/server/ccd # 固定客户端的ip地址 ifconfig-push 10.9.0.100 # 如果客户端后边还有一个子网192.168.40.128,可以在文件中加入： iroute 192.168.40.128 255.255.255.248 # 客户端后边的子网网段 # 给此客户客户端推送路由 push \"192.168.253.0 255.255.255.0\" # 以上三条命令是在ccd目录下当前客户端名称的文件配置的 # 服务端添加去客户端后边子网的路由 route 192.168.40.128 255.255.255.248 # 假设您希望为不同的客户端组启用不同的防火墙访问策略。有两种方法： # (1)运行多个OpenVPN进程，每个组一个，并为每个进程添加一个防火墙TUN/TAP接口。 # (2)（推荐）创建一个脚本来动态修改防火墙以响应来自不同客户端的访问，脚本不会 ;learn-address ./script # 这条命令可以重定向客户端的网关，在进行FQ时会使用到。也就是修改默认网关到vpn ;push \"redirect-gateway def1 bypass-dhcp\" # 向客户端推送的DNS信息。 ;push \"dhcp-option DNS 208.67.222.222\" ;push \"dhcp-option DNS 208.67.220.220\" # 这条命令可以使客户端之间能相互访问，默认设置下客户端间是不能相互访问的。 client-to-client # 定义openvpn一个证书在同一时刻是否允许多个客户端接入，默认没有启用。 ;duplicate-cn # 定义活动连接保时期限，以下配置的意思为：每隔10秒接收一次类似ping的消息，超过120秒没接收到，即判定对端下线 keepalive 10 120 # 为了加强SSL/TLS提供的额外安全性，创建一个“HMAC防火墙”来帮助阻止DoS攻击和UDP端口泛滥。 # 通过 openvpn --genkey --secret ta.key 命令生成ta.key # 服务器和每个客户端必须有此密钥。“0”代表服务器，“1”代表客户端。 tls-auth ta.key 0 # 这个文件应该保密 # 保证客户端和服务端使用一样，用于加密密码 cipher AES-256-CBC # 启用lz4-v2压缩，并将选项推送到客户端， ;compress lz4-v2 ;push \"compress lz4-v2\" # 与老客户端兼容的压缩，客户端配置文件也需要有这项。与上边的二选一 ;comp-lzo # 定义最大客户端并发连接数量 ;max-clients 100 # 定义openvpn运行时使用的用户及用户组。 user nobody group nobody # 通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys。 persist-key # 通过keepalive检测超时后，重新启动VPN，一直保持tun或者tap设备是linkup的。否则网络连接，会先linkdown然后再linkup。 persist-tun # 把openvpn的一些状态信息写到文件中，比如客户端获得的IP地址。 status /var/log/openvpn/server/openvpn-status.log # 记录日志，每次重新启动openvpn后删除原有的log信息。也可以自定义log的位置。默认是在/etc/openvpn/目录下。 log /var/log/openvpn/server/openvpn.log # 记录日志，每次重新启动openvpn后追加原有的log信息。 ;log-append /var/log/openvpn/server/openvpn.log # 设置日志记录冗长级别。 verb 3 # 重复日志记录限额 ;mute 20 # 通知客户端，当服务器重新启动时，它可以自动重新连接。使用tcp协议的时候这里需要注释掉 explicit-exit-notify 1 ######################################################################################### # # # 下面的配置为自定义配置，标准配置文档里边没有 # # # ######################################################################################### 启用服务 systemctl start openvpn@server # 启动服务 systemctl enable openvpn@server # 开机启动 firewall-cmd --add-service=openvpn --permanent --zone=public # 开启ip伪装 firewall-cmd --permanent --direct --passthrough ipv4 -t nat -I POSTROUTING -o eth0 -j MASQUERADE -s 192.168.250.0/24 # 设置ip伪装 firewall-cmd --reload # 设置生效 echo \"net.ipv4.ip_forward = 1\" \u003e\u003e /etc/sysctl.conf # 打开IP转发 systemctl restart network ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:3:1","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"3.2 客户端配置 打开客户端配置文件，并按照需要修改，把 “；”去掉即可启用 vim ~/openvpn/openvpn-client/client.conf # 定义这是一个client，配置从server端pull拉取过来，如IP地址，路由信息之类，Server使用push指令推送过来。 client # 定义openvpn运行的模式，这个地方需要严格和Server端保持一致。 dev tun ;dev tap # windwos系统如果有多个TAP-Win32适配器，这里需要指定名称，也需要禁用TAP适配器的防火墙，其他系统不用操作 ;dev-node MyTap # 定义openvpn使用的协议，这个地方需要严格和Server端保持一致。 proto udp ;proto tcp # 设置Server的IP地址和端口，这个地方需要严格和Server端保持一致。 # 如果有多台机器做负载均衡，可以多次出现remote关键字。 remote www.net-cc.com 1194 ;remote my-server-2 1194 # 随机选择一个Server连接，否则按照顺序从上到下依次连接。该选项默认不启用。 ;remote-random # 始终重新解析Server的IP地址（如果remote后面跟的是域名），保证Server IP地址是动态的使用DDNS动态更新DNS后， # Client在自动重新连接时重新解析Server的IP地址。这样无需人为重新启动，即可重新接入VPN。 resolv-retry infinite # 定义在本机不邦定任何端口监听incoming数据。 nobind # 定义openvpn运行时使用的用户及用户组。 ;user nobody ;group nobody # 尝试在重新启动时保留一些状态。 persist-key persist-tun # http代理配置，如果需要代理认证，请参照手册更改，具体没研究 ;http-proxy-retry # 关于连接失败的重试 ;http-proxy [proxy server] [proxy port #] # 无线网络常常会产生大量的重复数据包，开启可关闭此告警 ;mute-replay-warnings # 定义CA证书的文件名，用于验证Server CA证书合法性，该文件一定要与服务器端ca.crt是同一个文件。 ca ca.crt # 定义客户端的证书文件。 cert client.crt # 定义客户端的密钥文件。 key client.key # Server使用build-key-server脚本生成的，在x509 v3扩展中加入了ns-cert-type选项。防止client使用他们的keys ＋ DNS hack欺骗vpn client连接他们假冒的VPN Server，因为他们的CA里没有这个扩展。 remote-cert-tls server # 为了加强SSL/TLS提供的额外安全性，创建一个“HMAC防火墙”来帮助阻止DoS攻击和UDP端口泛滥。 # 通过 openvpn --genkey --secret ta.key 命令生成ta.key # 服务器和每个客户端必须有此密钥。“0”代表服务器，“1”代表客户端。 tls-auth ta.key 1 # 保证客户端和服务端使用一样，用于加密密码 cipher AES-256-CBC # 如果服务器启用了comp-lzo压缩，此处需要开启 ;comp-lzo # 设置日志记录冗长级别。 verb 3 # 重复日志记录限额 ;mute 20 ######################################################################################### # # # 下面的配置为自定义配置，标准配置文档里边没有 # # # ######################################################################################### # 不在内存里边保存账号秘钥和秘钥 auth-nocache ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:3:2","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"4 开启简单密码认证 首先按照前边的已经配置好了，用证书验证测试也可以通过了，可以更换成密码认证或者密码证书双认证 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:4:0","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"4.1 创建认证脚本 创建文件,并修改权限，psw-file的权限修改最小 mkdir -p /etc/openvpn/openvpn-passwd cd /etc/openvpn/openvpn-passwd touch checkpsw.sh openvpn-password.log psw-file touch /var/log/openvpn/server/openvpn-password.log chmod 400 psw-file | chown nobody:nobody psw-file chmod u+x checkpsw.sh 编辑checkpsw.sh 文件，添加一下内容 #!/bin/sh ########################################################### # checkpsw.sh (C) 2004 Mathias Sundman \u003cmathias@openvpn.se\u003e # # This script will authenticate OpenVPN users against # a plain text file. The passfile should simply contain # one row per user with the username first followed by # one or more space(s) or tab(s) and then the password. PASSFILE=\"/etc/openvpn/openvpn-passwd/psw-file\" LOG_FILE=\"/var/log/openvpn/server/openvpn-password.log\" TIME_STAMP=`date \"+%Y-%m-%d %T\"` ########################################################### if [ ! -r \"${PASSFILE}\" ]; then echo \"${TIME_STAMP}: Could not open password file \\\"${PASSFILE}\\\" for reading.\" \u003e\u003e ${LOG_FILE} exit 1 fi CORRECT_PASSWORD=`awk '!/^;/\u0026\u0026!/^#/\u0026\u0026$1==\"'${username}'\"{print $2;exit}' ${PASSFILE}` if [ \"${CORRECT_PASSWORD}\" = \"\" ]; then echo \"${TIME_STAMP}: User does not exist: username=\\\"${username}\\\", password=\\\"${password}\\\".\" \u003e\u003e ${LOG_FILE} exit 1 fi if [ \"${password}\" = \"${CORRECT_PASSWORD}\" ]; then echo \"${TIME_STAMP}: Successful authentication: username=\\\"${username}\\\".\" \u003e\u003e ${LOG_FILE} exit 0 fi echo \"${TIME_STAMP}: Incorrect password: username=\\\"${username}\\\", password=\\\"${password}\\\".\" \u003e\u003e ${LOG_FILE} exit 1 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:4:1","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["network"],"content":"4.2 修改配置文件 服务端 ############################# 密码认证部分（不需要密码的可以不填） ########################## # 加入脚本处理，如密码认证 script-security 3 # 开启密码认证，指定使用的认证脚本 auth-user-pass-verify /etc/openvpn/openvpn-passwd/checkpsw.sh via-env # 则代表只使用用户名密码方式验证登录，可以吧前边的crt和key注释掉 client-cert-not-required # 使用客户提供的UserName作为Common Name username-as-common-name ######################################################################################### 客户端 ############################# 密码认证部分（不需要密码的可以不填） ########################## # 开启密码认证，如果注释掉上边的key和cert文件的话就只有密码认证啦，并没有双重认证 auth-user-pass ######################################################################################### 创建用户账号 修改/etc/openvpn/openvpn-passwd/psw-file文件，格式如下： zhangcc 123456 mysql 123456 重启服务 systemctl restart openvpn@server 配置客户端自动输入密码登录 在配置文件目录里新建passwd.txt文件，编辑这个文件，并在第一行输入账号，第二行输入密码，如下： username password 编辑.ovpn或者.conf配置文件，修改 auth-user-pass auth-user-pass passwd.txt 然后再次连接的时候就不需要账号密码了 ","date":"2020-08-30","objectID":"/posts/network/vpn/01-openvpn/:4:2","tags":["vpn"],"title":"openvpn安装配置记录","uri":"/posts/network/vpn/01-openvpn/"},{"categories":["linux software"],"content":"PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"1 安装nodejs 我就不造轮子了，上大招官方链接 ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:1:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"2 安装PM2 ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:2:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"2.1 安装 sudo npm install -g pm2 # tab补全 pm2 completion install source ~/.bash_profile ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:2:1","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"2.2 目录介绍 pm2安装好后，会自动创建下面目录。看文件名基本就知道干嘛的了，就不翻译了。 $HOME/.pm2 will contain all PM2 related files $HOME/.pm2/logs will contain all applications logs $HOME/.pm2/pids will contain all applications pids $HOME/.pm2/pm2.log PM2 logs $HOME/.pm2/pm2.pid PM2 pid $HOME/.pm2/rpc.sock Socket file for remote commands $HOME/.pm2/pub.sock Socket file for publishable events $HOME/.pm2/conf.js PM2 Configuration ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:2:2","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"2.3 常用命令 启动服务 Usage: pm2 start appname [option] option: --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=“test node_modules “some scripts”” -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output \u003cpath\u003e：标准输出日志文件的路径。 -e --error \u003cpath\u003e：错误输出日志文件的路径。 --node-args \u003cargs\u003e: 传入到nodejs的参数 --interpreter \u003cinterpreter\u003e：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。 重启服务 Usage: pm2 restart appname 停止服务 Usage: pm2 stop appname|appid 停止一个服务 pm2 stop all 停止所有服务 删除服务 Usage: pm2 delete appname|appid|all 保存当前已经启动了的服务 Usage: pm2 save 设置开机自启的配置 Usage: pm2 startup pm2 startup以后会得到以下提示 [PM2] Init System found: upstart [PM2] To setup the Startup Script, copy/paste the following command: sudo env PATH=$PATH:/opt/nodejs/bin /opt/nodejs/lib/node_modules/pm2/bin/pm2 startup systemd -u cc --hp /home/cc 按照上边的提示设置systemd启动脚本 sudo env PATH=$PATH:/opt/nodejs/bin /opt/nodejs/lib/node_modules/pm2/bin/pm2 startup systemd -u cc --hp /home/cc 启动systemd服务 systemctl enable pm2-cc 查看进程 Usage: pm2 list 查看某个进程状态 Usage: pm2 describe appid 查看日志 Usage: pm2 logs ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:2:3","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"3 启动服务配置文件 配置文件里的设置项，跟命令行参数基本是一一对应的。 可以选择yaml或者json文件, 看个人喜好 json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。 参考官方文档中的例子: { \"name\" : \"fis-receiver\", // 应用名称 \"script\" : \"./bin/www\", // 实际启动脚本 \"cwd\" : \"./\", // 当前工作路径 \"watch\": [ // 监控变化的目录，一旦变化，自动重启 \"bin\", \"routers\" ], \"ignore_watch\" : [ // 从监控目录中排除 \"node_modules\", \"logs\", \"public\" ], \"watch_options\": { \"followSymlinks\": false }, \"error_file\" : \"./logs/app-err.log\", // 错误日志路径 \"out_file\" : \"./logs/app-out.log\", // 普通日志路径 \"env\": { \"NODE_ENV\": \"production\" // 环境参数，当前指定为生产环境 } } ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:3:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"4 环境切换 ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:4:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"4.1 环境配置声明 首先，在配置文件中，通过env选项声明多个环境配置。简单说明下： env为默认的环境配置（生产环境），env_dev、env_test则分别是开发、测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。 在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。 \"env\": { \"NODE_ENV\": \"production\", \"REMOTE_ADDR\": \"http://www.example.com/\" }, \"env_dev\": { \"NODE_ENV\": \"development\", \"REMOTE_ADDR\": \"http://wdev.example.com/\" }, \"env_test\": { \"NODE_ENV\": \"test\", \"REMOTE_ADDR\": \"http://wtest.example.com/\" } ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:4:1","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"4.2 启动指明环境 假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的 http://wdev.example.com/。 pm2 start app.js --env dev ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:4:2","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"5 负载均衡 命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。 参考 pm2 start app.js -i 3 # 开启三个进程 pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:5:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"6 更新PM2 官方文档 $ pm2 save # 记得保存进程状态 $ npm install pm2 -g $ pm2 update ","date":"2020-08-30","objectID":"/posts/linux-software/02-pm2/:6:0","tags":["nodejs"],"title":"PM2实用指南","uri":"/posts/linux-software/02-pm2/"},{"categories":["linux software"],"content":"记录了selinux的运行方式，如果查看权限拒绝，如何放行等等","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"记录了selinux的运行方式，如果查看权限拒绝，如何放行等等 selinux的学习记录 ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:0:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"1 运行模式 强制访问控制（Mandatory Access Control，MAC）：通过selinux的默认规则来控制进程的权限 自主访问控制系统（Discretionary Access Control，DAC）：通过user、group、rwx来控制不同用户对不同文件的读写执行权限，root用户不受到限制，特殊权限SetUID可以使普通用户以root权限执行拥护SetUID权限的程序 开启selinux后必须同时满足MAC和DAC规则才可以正确运行程序 主体(Subject): 访问文件或目录资源的进程 目标(Object): 需要访问的文件或目录资源 策略(Policy): 通过cat /etc/sysconfig/selinux来查看selinux的状态和默认策略 Selinux默认定义了三个策略，规则都已经在这三个策略中写好了，默认只要调用策略就可以正常使用了。这两个默认策略如下： targeted：这是 SELinux 的默认策略，这个策略主要是限制网络服务的，对本机系统的限制极少。我们使用这个策略已经足够了。 mls: 完整的SELinux 限制，限制方面较为严格。 minimum：由target修订而来，仅针对选择的程序来保护！ 安全上下文(Security Context): 每个进程、目录和文件都有自己的安全上下文，进程能否访问目录/文件，需要判断两者的安全上下文是否匹配，然后进行比较，符合就通过，不符合就AVC拒绝 selinux运行模式图示 主体的访问请求首先和Selinux中定义好的策略进行匹配，如果进程符合策略中定义的规则，就把进程的安全上下文和目标的安全上下文进行匹配，如果失败则访问拒绝，并通过AVC（Access Vector Cache，访问向量缓存，主要用于记录所有和 SELinux 相关的访问统计信息)生成拒绝访问信息，如果安全上下文匹配，则通过Selinux控制 ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:1:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"2 更改安全上下文 查看文件的安全上下文： # 查看文件的安全上下文 ls -Z # 查看进程的安全上下文 ps -auxZ 如上所是的root:object_r:user_home_t对应为：身份识别(Identify):角色(role):类型(type) restorecon: 恢复目录或者程序的默认安全上下文 sudo restorecon -Rv -f /var/sshd chcon: sudo chcon -R -t ssh_home_t ~/.ssh/authorized_keys semanage: 添加到默认规则里，以后使用restorecon即可恢复，不会存在下载就没有了 # 查看文件安全上下文的默认类型 $ sudo semanage fcontext -l # 更改文件安全上下文的默认类型 $ sudo semanage fcontext -a -t public_content_t \"/srv/samba(/.*)?\" restorecon -Rv /srv/samba* $ sudo ls -Zd /srv/samba drwxr-xr-x root root system_u:object_r:public_content_t /srv/samba/ # 查看网络端口限制 $ sudo semanage port -l | grep ssh ssh_port_t tcp 22 $ sudo semanage port -a -t ssh_port_t -p tcp 3322 $ sudo semanage port -l | grep ssh ssh_port_t tcp 3322, 22 # 其他参数请通过 `semanage --help` 或 `man semanage` 查看 ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:2:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"3 查看Selinux规则 sesearch: # 查看类型为 inetd_t 的selinux规则 sesearch -A -t inetd_t seinfo: # 查看所有的类型 seinfo -b ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:3:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"4 查看/添加Selinux模块 SELinux策略是一系列的模块化规则集合，安装时它会基于已经安装的服务自动探测并启用相关模块。系统立即可操作。然而，如果一个服务是在 SELinux 策略之后安装的，就要手动启用相应模块了。semodule 命令可以实现该目的。还必须用 semanage 命令，定义每个用户可用的角色。 semanage: # 查看所有模块 semanage module -l # 禁用一个模块 semanage module --disable unconfined # 安装一个模块 semanage module -a myapache # 查看其他参数 semanage module --help man semanage module semodule: # Install or replace a base policy package. semodule -b base.pp # Install or replace a non-base policy package. semodule -i httpd.pp # Install or replace all non-base modules in the current directory. # This syntax can be used with -i/u/r/E, but no other option can be entered after the module names semodule -i *.pp # Install or replace all modules in the current directory. ls *.pp | grep -Ev \"base.pp|enableaudit.pp\" | xargs /usr/sbin/semodule -b base.pp -i # List non-base modules. semodule -l # List all modules including priorities semodule -lfull # Remove a module at priority 100 semodule -X 100 -r wireshark # Turn on all AVC Messages for which SELinux currently is \"dontaudit\"ing. semodule -DB # Turn \"dontaudit\" rules back on. semodule -B # Disable a module (all instances of given module across priorities will be disabled). semodule -d alsa # Install a module at a specific priority. semodule -X 100 -i alsa.pp # List all modules. semodule --list=full # Set an alternate path for the policy root semodule -B -p \"/tmp\" # Set an alternate path for the policy store root semodule -B -S \"/tmp/var/lib/selinux\" # Write the HLL version of puppet and the CIL version of wireshark # modules at priority 400 to the current working directory semodule -X 400 --hll -E puppet --cil -E wireshark ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:4:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"5 查看/修改bool值 getsebool or setatus # 查看所有bool getsebool -a sestatus -b sesearch 查看一个bool包含的selinux规则 # 查看 httpd_can_network_connect_db 布尔值包含的selinux规则 sesearch -A -b httpd_can_network_connect_db setsebool # 允许vsvtp匿名用户写入权限： setsebool -P allow_ftpd_anon_write=1 ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:5:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["linux software"],"content":"6 查看/分析Selinux日志，并解决问题 启用auditd服务 sudo dnf install audit sudo systemctl enable auditd sudo systemctl start auditd 查看audit日志 audit2why: # 查看本次启动所有关于selinux拒绝的信息，并给出解决方案，不过大部分没有0.0,并且不准确或者解决方案的权限过大 sudo audit2why -b audit2allow: # 详细查看selinux的avc拒绝信息 sudo audit2allow -b 制作selinux模块,并安装 如果不能通过修改bool值、文件安全上下文等来解决问题，可以通过audit2allow命令生成selinux模块并加载，来解决问题 # 利用`audit2allow`生成`selinux`模块 sudo audit2allwo -b -M local # 倒入`local`模块 sudo semodule -i local.pp ","date":"2020-08-30","objectID":"/posts/linux-software/03-selinux/:6:0","tags":["linux"],"title":"selinux的学习记录","uri":"/posts/linux-software/03-selinux/"},{"categories":["network"],"content":"通过二进制方式安装ss，用来做国际优化","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["network"],"content":"通过二进制方式安装ss，在阿里云香港购买一台服务器，用来做国际优化 ","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/:0:0","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["network"],"content":"1 安装shadowsocks-libev服务端 存储库安装 cd /etc/yum.repos.d/ wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo yum check yum install epel-release -y yum install shadowsocks-libev -y 编译安装 安装需要的lib库 yum install epel-release -y yum install gcc make pcre-devel mbedtls-devel libsodium-devel c-ares-devel libev-devel libnetfilter_conntrack-devel libnetfilter_conntrack -y # 如果要安装文档的还需要以下几个依赖 yum install gettext autoconf libtool automeke xmlto -y 下载软件，解压缩 cd /usr/local/src wget https://github.com/shadowsocks/shadowsocks-libev/releases/download/v3.2.3/shadowsocks-libev-3.2.3.tar.gz tar -xvf shadowsocks-libev-3.2.3.tar.gz cd shadowsocks-libev-3.2.3 mkdir /opt/shadowsocks-libev 编译安装 ./configure --prefix=/opt/shadowsocks-libev/ \\ --disable-documentation make make install 添加系统服务 cd /usr/local/src/shadowsocks-libev-3.2.3 cp rpm/SOURCES/systemd/shadowsocks-libev.service /usr/lib/systemd/system/ cp rpm/SOURCES/systemd/shadowsocks-libev.default /etc/sysconfig/shadowsocks-libev # 编辑服务文件，修改`/usr/bin/`为`/opt/shadowsocks-libev/` sed -i 's/\\/usr\\/bin\\//\\/opt\\/shadowsocks-libev\\/bin\\//g' /usr/lib/systemd/system/shadowsocks-libev.service # 开机启动服务 systemctl daemon-reload systemctl enable shadowsocks-libev.service # 这里启动服务会失败，因为没有配置文件 systemctl start shadowsocks-libev.service docker安装 参考docker hub上的介绍 配置 编辑配置文件 # 添加配置文件 cat \u003e /etc/shadowsocks-libev/config.json \u003c\u003cEOF { \"server\":[\"[::0]\",\"0.0.0.0\"], \"server_port\":19438, \"local_port\":1081, \"password\":\"cc951021\\$ps\", \"timeout\":60, \"method\":\"chacha20-ietf-poly1305\" } EOF 优化 参照这一篇文章进行优化shadowsocks advanced config cat \u003e /etc/sysctl.d/98-shadowsocks.conf \u003c\u003cEOF # max open files fs.file-max = 51200 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # turn on TCP Fast Open on both client and server side net.ipv4.tcp_fastopen = 3 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for high-latency network net.ipv4.tcp_congestion_control = hybla # for low-latency network, use cubic instead # net.ipv4.tcp_congestion_control = cubic EOF sysctl -p /etc/sysctl.d/98-shadowsocks.conf ","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/:1:0","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["network"],"content":"2 安装shadowsocks客户端 安卓 google play商店下载 备用下载地址 ios 商店下载 linux linux的安装步骤和安装服务端一样 也可以安装shadowsocks-qt5版本，不过我感觉libev版本配合chrome的SwitchyOmega插件挺好用的 安装后的配置 cat \u003e /etc/shadowsocks-libev/config.json \u003c\u003cEOF { \"server\":[\"service-ip\"], \"server_port\":server-port, \"local_port\":1081, \"password\":\"server-passwd\", \"timeout\":60, \"method\":\"server加密算法\" } 添加系统服务 cp rpm/SOURCES/systemd/shadowsocks-libev-local.service /usr/lib/systemd/system/ sed -i 's/\\/usr\\/bin\\//\\/opt\\/shadowsocks-libev\\/bin\\//g' /usr/lib/systemd/system/shadowsocks-libev-local.service # 开机启动服务 systemctl daemon-reload systemctl enable shadowsocks-libev-local.service systemctl start shadowsocks-libev-local.servic windows 下载地址 macOS 下载地址 ","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/:2:0","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["network"],"content":"3 安装shadowsocks-manager shadowsocks-manager是shadowsocks-libev的管理工具，需要先安装shadowsocks-libev服务端然后启用shadowsocks-libev的API和shadowsocks-manager对接 安装nodejs 我就不造轮子了，上大招官方链接 安装sqlite sqlite一般都自带的无需安装 yum install sqlite 安装shadowsocks-manager 拓扑 +-------------+ +-------------+ +------+ | Shadowsocks | | Shadowsocks | ... | | | manager API | | manager API | | | +-------------+ +-------------+ +------+ | | | | | | +-------------+ +-------------+ +------+ | ssmgr | | ssmgr | ... | | | with type s | | with type s | | | +-------------+ +-------------+ +------+ | | | +------------+----+-------- ... ---+ | | +---------------+ | ssmgr plugins | | with type m | +---------------+ 从源代码安装 git clone https://github.com/shadowsocks/shadowsocks-manager.git cd shadowsocks-manager npm i -g 从NPM安装 升级前请做好备份,请勿跨版本升级，例如0.21.0可以升级到0.22.x，但不能直接升级到0.23.x 通过NPM安装的可执行文件(ssmgr):/opt/nodejs/bin,程序文件:ib/node_modules/shadowsocks-manager/ npm i -g shadowsocks-manager or npm i -g shadowsocks-manager --unsafe-perm # 升级 a.b.c为版本号 npm i -g shadowsocks-manager@a.b.c 配置shadowsocks-manager 创建配置文件 cat \u003e $HOME/.ssmgr/default.yml \u003c\u003cEOF type: s shadowsocks: address: 127.0.0.1:6001 manager: address: webgui的ip地址:59418 password: '951021@cc' db: 'db.sqlite' EOF 启动节点 pm2 --name \"node\" -f start ssmgr -x -- -c $HOME/.ssmgr/default.yml -r libev:chacha20-ietf-poly1305 配置webgui 每个节点都需要按照以上进行配置，web只需要在一个节点上配置就好了，简单来说是web页面利用shadowsocks-manager的webgui扩展通过每个节点的ssmgr(‘shadowsocks-manager’)程序调用shadowsocks的API控制shadowsocks的 创建配置文件 在$HOME/.ssmgr目录下创建一个web.yml文件，内容如下 type: m manager: address: 127.0.0.1:59418 password: '951021@cc' # 这部分的端口和密码需要跟上一步 manager 参数里的保持一致，以连接 type s 部分监听的 tcp 端口 plugins: flowSaver: use: true user: use: true account: use: true macAccount: use: true group: use: true email: use: true type: 'smtp' username: 'username' password: 'password' host: 'smtp.your-email.com' # 这部分的邮箱和密码是用于发送注册验证邮件，重置密码邮件 webgui: use: true host: '0.0.0.0' port: '80' site: 'http://yourwebsite.com' # cdn: 'http://xxx.com' # 静态资源cdn地址，可省略 # icon: 'icon.png' # 自定义首页图标，默认路径在 ~/.ssmgr 可省略 # skin: 'default' # 首页皮肤，可省略 # googleAnalytics: 'UA-xxxxxxxx-x' # Google Analytics ID，可省略 gcmSenderId: '456102641793' gcmAPIKey: 'AAAAGzzdqrE:XXXXXXXXXXXXXX' webgui_telegram: // telegram 机器人的配置，可省略 use: true token: '191374681:AAw6oaVPR4nnY7T4CtW78QX-Xy2Q5WD3wmZ' alipay: # 如果不使用支付宝，这段可以去掉 use: true appid: 2015012108272442 notifyUrl: 'http://yourwebsite.com/api/user/alipay/callback' merchantPrivateKey: 'xxxxxxxxxxxx' alipayPublicKey: 'xxxxxxxxxxx' gatewayUrl: 'https://openapi.alipay.com/gateway.do' paypal: # 如果不使用paypal，这段可以去掉 use: true mode: 'live' # sandbox or live client_id: 'At9xcGd1t5L6OrICKNnp2g9' client_secret: 'EP40s6pQAZmqp_G_nrU9kKY4XaZph' db: 'webgui.sqlite' 启动web pm2 --name \"web\" -f start ssmgr -x -- -c $HOME/.ssmgr/web.yml ","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/:3:0","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["network"],"content":"4 安装配置KCPtun 加速tcp传输，但会造成双倍流量，不建议，流量贵～～～ ","date":"2020-08-30","objectID":"/posts/network/vpn/02-shadowsocks/:4:0","tags":["vpn"],"title":"shadowsocks","uri":"/posts/network/vpn/02-shadowsocks/"},{"categories":["linux software"],"content":"使用编译的方式在linux服务器上安装git","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"使用编译的方式在linux服务器上安装git git学习笔记 ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:0:0","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"1 配置编译环境 ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:1:0","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"1.1 下载源代码包 mkdir ~/src cd ~/src wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.1.tar.gz ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:1:1","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"1.2 安装依赖库文件 yum install curl-devel expat-devel openssl-devel zlib-devel asciidoc ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:1:2","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"2 编译配置 ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:2:0","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"2.1 编译 mkdir /opt/git make prefix=/opt/git/ all sudo make prefix=/opt/git/ install echo $? # 查看是否编译安装完成 ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:2:1","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"2.2 设置环境变量 mkdir /opt/bin ln -s /opt/git/bin/* /opt/bin echo \"export PATH=$PATH:/opt/bin/\" \u003e\u003e /etc/profile source /etc/profile ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:2:2","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"},{"categories":["linux software"],"content":"2.3 测试 git --version # 初始化 git config --global user.email \"alex_zjf@163.com\" git config --global user.name \"cc\" git config --global user.editor \"vim\" ","date":"2020-08-30","objectID":"/posts/linux-software/01-install-git/:2:3","tags":["git"],"title":"编译安装git","uri":"/posts/linux-software/01-install-git/"}]